type 'a array = 'a array
datatype bool = false | true
eqtype char = char
type exn = exn
type int = int
datatype 'a list = nil | :: of 'a * 'a list
datatype 'a option = None | Some of 'a
datatype order = Equal | Greater | Less
type 'a seq = 'a seq
eqtype string = string
type 'a thunk = unit -> 'a
eqtype unit = unit
type 'a vector = 'a vector
type word = word
val * : ('a * 'a) -> 'a
val + : ('a * 'a) -> 'a
val - : ('a * 'a) -> 'a
val / : ('a * 'a) -> 'a
val < : ('a * 'a) -> bool
val <= : ('a * 'a) -> bool
val <> : ('a * 'a) -> bool
val = : ('a * 'a) -> bool
val > : ('a * 'a) -> bool
val >= : ('a * 'a) -> bool
val @ : ('a list * 'a list) -> 'a list
val abs: 'a -> 'a
val concat: string seq -> string
val die: string -> 'a
val div: ('a * 'a) -> 'a
val finally: ((unit -> 'a) * (unit -> unit)) -> 'a
val ignore: 'a -> unit
val lazy: (unit -> 'a) -> (unit -> 'a)
val mod: ('a * 'a) -> 'a
val not: bool -> bool
val o: (('a -> 'b) * ('c -> 'a)) -> ('c -> 'b)
val print: string -> unit
val valOf: 'a option -> 'a
val ~ : 'a -> 'a
structure Array: ARRAY
		 where type 'a elem = 'a Array.elem
		 where type 'a t = 'a ArraySlice.base
		 where type 'a unfold = 'a Array.unfold
		 where type 'a unfoldR = 'a Array.unfoldR
structure ArraySlice: ARRAY_SLICE
		      where type 'a base = 'a ArraySlice.base
		      where type 'a elem = 'a ArraySlice.elem
		      where type 'a t = 'a ArraySlice.t
structure Bool: BOOL
structure Char: CHAR
		where type t = char
structure CommandLine: COMMAND_LINE
structure Date: DATE
		where type Month.t = Date.Month.t
		where type WeekDay.t = Date.WeekDay.t
		where type t = Date.t
structure Dir: DIR
	       where type Stream.t = Dir.Stream.t
structure Endian: ENDIAN
		  where type t = Endian.t
structure Exn: EXN
	       where type t = exn
structure File: FILE
		where type AccessMode.t = File.AccessMode.t
		where type Id.t = File.Id.t
structure In: IN
	      where type t = In.t
structure Int: INT
	       where type t = int
structure Int16: INT
		 where type t = Int16.t
structure Int32: INT
		 where type t = Int32.t
structure Int64: INT
		 where type t = Int64.t
structure Int8: INT
		where type t = Int8.t
structure IntInf: INT_INF
		  where type t = IntInf.t
structure IoDesc: IO_DESC
		  where type Kind.t = IoDesc.Kind.t
		  where type t = IoDesc.t
structure LargeInt: INT
		    where type t = LargeInt.t
structure LargeReal: REAL
		     where type Class.t = LargeReal.Class.t
		     where type Format.t = LargeReal.Format.t
		     where type RoundingMode.t = LargeReal.RoundingMode.t
		     where type t = LargeReal.t
structure LargeWord: WORD
		     where type t = LargeWord.t
structure Lazy: LAZY
structure List: LIST
		where type 'a elem = 'a List.elem
		where type 'a unfold = 'a List.unfold
		where type 'a unfoldR = 'a List.unfoldR
structure Net: NET
	       where type Family.inet = Net.Family.inet
	       where type 'a Family.t = 'a Net.Family.t
	       where type Family.unix = Net.Family.unix
	       where type Family.unknown = Net.Family.unknown
	       where type Host.Address.t = Net.Host.Address.t
	       where type Host.t = Net.Host.t
	       where type Protocol.t = Net.Protocol.t
	       where type Service.t = Net.Service.t
	       where type 'a Socket.Address.t = 'a Net.Socket.Address.t
	       where type ('a, 'b, 'c) Socket.Block.t = ('a, 'b, 'c) Net.Socket.Block.t
	       where type Socket.Desc.t = Net.Socket.Desc.t
	       where type Socket.Option.ro = Net.Socket.Option.ro
	       where type Socket.Option.rw = Net.Socket.Option.rw
	       where type ('a, 'b, 'c, 'd) Socket.Option.t = ('a, 'b, 'c, 'd) Net.Socket.Option.t
	       where type ('a, 'b, 'c, 'd, 'e, 'f, 'g, 'h, 'i) Socket.Receive.Block.t = ('a,
											 'b,
											 'c,
											 'd,
											 'e,
											 'f,
											 'g,
											 'h,
											 'i) Net.Socket.Receive.Block.t
	       where type Socket.Receive.Flag.t = Net.Socket.Receive.Flag.t
	       where type ('a, 'b, 'c, 'd) Socket.Receive.From.t = ('a,
								    'b,
								    'c,
								    'd) Net.Socket.Receive.From.t
	       where type ('a, 'b, 'c, 'd, 'e, 'f, 'g) Socket.Receive.To.t = ('a,
									      'b,
									      'c,
									      'd,
									      'e,
									      'f,
									      'g) Net.Socket.Receive.To.t
	       where type ('a, 'b, 'c, 'd, 'e, 'f, 'g) Socket.Send.Block.t = ('a,
									      'b,
									      'c,
									      'd,
									      'e,
									      'f,
									      'g) Net.Socket.Send.Block.t
	       where type Socket.Send.Flag.t = Net.Socket.Send.Flag.t
	       where type Socket.Send.From.t = Net.Socket.Send.From.t
	       where type ('a, 'b, 'c, 'd) Socket.Send.To.t = ('a, 'b, 'c, 'd) Net.Socket.Send.To.t
	       where type Socket.ShutdownMode.t = Net.Socket.ShutdownMode.t
	       where type Socket.Type.active = Net.Socket.Type.active
	       where type Socket.Type.dgram = Net.Socket.Type.dgram
	       where type Socket.Type.passive = Net.Socket.Type.passive
	       where type 'a Socket.Type.stream = 'a Net.Socket.Type.stream
	       where type 'a Socket.Type.t = 'a Net.Socket.Type.t
	       where type Socket.Type.unknown = Net.Socket.Type.unknown
	       where type ('a, 'b) Socket.sock = ('a, 'b) Net.Socket.sock
structure Option: OPTION
		  where type 'a t = 'a option
structure Order: ORDER
		 where type t = Order.t
structure Out: OUT
	       where type t = Out.t
structure Path: PATH
		where type Pieces.t = Path.Pieces.t
structure Poll: POLL
		where type Desc.t = Poll.Desc.t
		where type Info.t = Poll.Info.t
structure Posix: POSIX
		 where type AccessMode.t = Posix.AccessMode.t
		 where type Dev.t = Posix.Dev.t
		 where type DirStream.t = Posix.DirStream.t
		 where type Error.t = Posix.Error.t
		 where type ExitStatus.t = Posix.ExitStatus.t
		 where type ('a, 'b) Fcntl.t = ('a, 'b) Posix.Fcntl.t
		 where type FileDesc.t = Posix.FileDesc.t
		 where type FileDescFlags.t = Posix.FileDescFlags.t
		 where type FileStatusFlags.t = Posix.FileStatusFlags.t
		 where type FlowAction.t = Posix.FlowAction.t
		 where type Gid.t = Posix.Gid.t
		 where type Group.t = Posix.Group.t
		 where type Ino.t = Posix.Ino.t
		 where type KillArg.t = Posix.KillArg.t
		 where type Lock.Type.t = Posix.Lock.Type.t
		 where type Lock.t = Posix.Lock.t
		 where type Mode.t = Posix.Mode.t
		 where type OpenFlags.t = Posix.OpenFlags.t
		 where type OpenMode.t = Posix.OpenMode.t
		 where type Passwd.t = Posix.Passwd.t
		 where type Pid.t = Posix.Pid.t
		 where type QueueSel.t = Posix.QueueSel.t
		 where type SetAction.t = Posix.SetAction.t
		 where type Signal.t = Posix.Signal.t
		 where type Stat.t = Posix.Stat.t
		 where type Termios.C.t = Posix.Termios.C.t
		 where type Termios.CC.t = Posix.Termios.CC.t
		 where type Termios.I.t = Posix.Termios.I.t
		 where type Termios.L.t = Posix.Termios.L.t
		 where type Termios.O.t = Posix.Termios.O.t
		 where type Termios.Speed.t = Posix.Termios.Speed.t
		 where type Termios.t = Posix.Termios.t
		 where type Uid.t = Posix.Uid.t
		 where type WaitPidArg.t = Posix.WaitPidArg.t
		 where type WaitPidFlags.t = Posix.WaitPidFlags.t
		 where type Whence.t = Posix.Whence.t
structure Process: PROCESS
		   where type Status.t = Process.Status.t
structure Radix: RADIX
		 where type t = Radix.t
structure Real: PACKABLE_REAL
		where type Class.t = Real.Class.t
		where type Format.t = Real.Format.t
		where type RoundingMode.t = Real.RoundingMode.t
		where type t = Real.t
structure Real32: PACKABLE_REAL
		  where type Class.t = Real32.Class.t
		  where type Format.t = Real32.Format.t
		  where type RoundingMode.t = Real32.RoundingMode.t
		  where type t = Real32.t
structure Real64: PACKABLE_REAL
		  where type Class.t = Real64.Class.t
		  where type Format.t = Real64.Format.t
		  where type RoundingMode.t = Real64.RoundingMode.t
		  where type t = Real64.t
structure Ref: REF
structure Scanner: SCANNER
		   where type 'a t = 'a Scanner.t
structure Seq: SEQ
	       where type 'a elem = 'a Seq.elem
	       where type 'a t = 'a seq
	       where type 'a unfold = 'a Seq.unfold
	       where type 'a unfoldR = 'a Seq.unfoldR
structure String: STRING
		  where type t = string
		  where type 'a unfold = 'a String.unfold
		  where type 'a unfoldR = 'a String.unfoldR
structure Substring: SUBSTRING
		     where type 'a base = 'a Substring.base
		     where type t = Substring.t
structure SysError: SYS_ERROR
		    where type Exn.t = SysError.Exn.t
		    where type t = SysError.t
structure Time: TIME
		where type t = Time.t
structure Vector: VECTOR
		  where type 'a elem = 'a Vector.elem
		  where type 'a t = 'a vector
		  where type 'a unfold = 'a Vector.unfold
		  where type 'a unfoldR = 'a Vector.unfoldR
structure VectorSlice: VECTOR_SLICE
		       where type 'a base = 'a vector
		       where type 'a elem = 'a VectorSlice.elem
		       where type 'a t = 'a VectorSlice.t
structure Word: WORD
		where type t = word
structure Word16: WORD
		  where type t = Word16.t
structure Word32: PACKABLE_WORD
		  where type t = Word32.t
structure Word64: WORD
		  where type t = Word64.t
structure Word8: WORD
		 where type t = Word8.t
signature ARRAY = 
   sig
      type 'a elem = 'a ?.elem
      type 'a t = 'a ?.t
      type 'a t0 = 'a ?.t
      type 'a unfold = 'a ?.unfold
      type 'a unfoldR = 'a ?.unfoldR
      val all: ('a ?.t * ('a ?.elem -> bool)) -> bool
      val append: ('a ?.t * 'a ?.t) -> 'a ?.t
      val concat: 'a ?.t seq -> 'a ?.t
      val cons: ('a ?.elem * 'a ?.t) -> 'a ?.t
      val drop: ('a ?.t * ('a ?.elem -> bool)) -> 'a ?.t
      val dropPrefix: ('a ?.t * ('a ?.elem -> bool)) -> 'a ?.t
      val dropPrefixN: ('a ?.t * Int32.t) -> 'a ?.t
      val dropSuffix: ('a ?.t * ('a ?.elem -> bool)) -> 'a ?.t
      val dropSuffixN: ('a ?.t * Int32.t) -> 'a ?.t
      val empty: unit -> 'a ?.t
      val exists: ('a ?.t * ('a ?.elem -> bool)) -> bool
      val fields: ('a ?.t * ('a ?.elem -> bool)) -> 'a ?.t seq
      val find: ('a ?.t * ('a ?.elem -> bool)) -> 'a ?.elem option
      val fold: ('a ?.t * 'b * (('a ?.elem * 'b) -> 'b)) -> 'b
      val for: ('a ?.t * ('a ?.elem -> unit)) -> unit
      val isEmpty: 'a ?.t -> bool
      val join: ('a ?.t seq * 'a ?.t) -> 'a ?.t
      val keep: ('a ?.t * ('a ?.elem -> bool)) -> 'a ?.t
      val keepPrefix: ('a ?.t * ('a ?.elem -> bool)) -> 'a ?.t
      val keepPrefixN: ('a ?.t * Int32.t) -> 'a ?.t
      val keepSuffix: ('a ?.t * ('a ?.elem -> bool)) -> 'a ?.t
      val keepSuffixN: ('a ?.t * Int32.t) -> 'a ?.t
      val last: 'a ?.t -> 'a ?.elem
      val make: (Int32.t * 'a) -> 'a ?.t
      val map: ('a ?.t * ('a ?.elem -> 'b ?.elem)) -> 'b ?.t
      val ofSeq: 'a ?.elem seq -> 'a ?.t
      val ofSeqN: ('a ?.elem seq * Int32.t) -> 'a ?.t
      val recur: ('a ?.t
		  * 'b
		  * ('b -> 'c)
		  * (('a ?.elem * 'b * ('b -> 'c)) -> 'c))
		 -> 'c
      val reverse: 'a ?.t -> 'a ?.t
      val separate: ('a ?.t * 'a ?.elem) -> 'a ?.t
      val single: 'a ?.elem -> 'a ?.t
      val size: 'a ?.t -> Int32.t
      val splitPrefix: ('a ?.t * ('a ?.elem -> bool)) -> ('a ?.t * 'a ?.t)
      val sub: ('a ?.t * Int32.t) -> 'a ?.elem
      val tabulate: (Int32.t * (Int32.t -> 'a ?.elem)) -> 'a ?.t
      val toSeq: 'a ?.t -> 'a ?.elem seq
      val toSeqR: 'a ?.t -> 'a ?.elem seq
      val tokens: ('a ?.t * ('a ?.elem -> bool)) -> 'a ?.t seq
      val unfold: ('a * ('a -> ('b ?.elem * 'a) option))
		  -> ('b ?.t * 'a ?.unfold)
      val unfoldN: (Int32.t * 'a * ((Int32.t * 'a) -> ('b ?.elem * 'a) option))
		   -> ('b ?.t * 'a ?.unfold)
      val unfoldNR: (Int32.t * 'a * ((Int32.t * 'a) -> ('b ?.elem * 'a) option))
		    -> ('b ?.t * 'a ?.unfoldR)
      val unfoldR: ('a * ('a -> ('b ?.elem * 'a) option))
		   -> ('b ?.t * 'a ?.unfoldR)
      val update: ('a ?.t * Int32.t * 'a) -> unit
      val updates: ('a ?.t * Int32.t * 'a seq) -> unit
      structure Unsafe:
	 sig
	    val make: Int32.t -> 'a ?.t
	    val sub: ('a ?.t * Int32.t) -> 'a
	    val update: ('a ?.t * Int32.t * 'a) -> unit
	 end
   end
signature ARRAY_SLICE = 
   sig
      type 'a base = 'a ?.base
      type 'a elem = 'a ?.elem
      type 'a t = 'a ?.t
      type 'a t0 = 'a ?.t
      val all: ('a ?.t * ('a ?.elem -> bool)) -> bool
      val base: 'a ?.t -> ('a ?.base * {start: Int32.t})
      val dropPrefix: ('a ?.t * ('a ?.elem -> bool)) -> 'a ?.t
      val dropPrefixN: ('a ?.t * Int32.t) -> 'a ?.t
      val dropSuffix: ('a ?.t * ('a ?.elem -> bool)) -> 'a ?.t
      val dropSuffixN: ('a ?.t * Int32.t) -> 'a ?.t
      val exists: ('a ?.t * ('a ?.elem -> bool)) -> bool
      val fields: ('a ?.t * ('a ?.elem -> bool)) -> 'a ?.t seq
      val find: ('a ?.t * ('a ?.elem -> bool)) -> 'a ?.elem option
      val fold: ('a ?.t * 'b * (('a ?.elem * 'b) -> 'b)) -> 'b
      val for: ('a ?.t * ('a ?.elem -> unit)) -> unit
      val full: 'a ?.base -> 'a ?.t
      val get: 'a ?.t -> ('a ?.elem * 'a ?.t) option
      val isEmpty: 'a ?.t -> bool
      val keepPrefix: ('a ?.t * ('a ?.elem -> bool)) -> 'a ?.t
      val keepPrefixN: ('a ?.t * Int32.t) -> 'a ?.t
      val keepSuffix: ('a ?.t * ('a ?.elem -> bool)) -> 'a ?.t
      val keepSuffixN: ('a ?.t * Int32.t) -> 'a ?.t
      val last: 'a ?.t -> 'a ?.elem
      val map: ('a ?.t * ('a ?.elem -> 'b ?.elem)) -> 'b ?.base
      val recur: ('a ?.t
		  * 'b
		  * ('b -> 'c)
		  * (('a ?.elem * 'b * ('b -> 'c)) -> 'c))
		 -> 'c
      val size: 'a ?.t -> Int32.t
      val slice: ('a ?.t * {size: Int32.t, start: Int32.t}) -> 'a ?.t
      val splitPrefix: ('a ?.t * ('a ?.elem -> bool)) -> ('a ?.t * 'a ?.t)
      val sub: ('a ?.t * Int32.t) -> 'a ?.elem
      val toSeq: 'a ?.t -> 'a ?.elem seq
      val toSeqR: 'a ?.t -> 'a ?.elem seq
      val tokens: ('a ?.t * ('a ?.elem -> bool)) -> 'a ?.t seq
   end
signature BOOL = 
   sig
      datatype t = false | true
      val not: bool -> bool
   end
signature CHAR = 
   sig
      type t = ?.t
      val < : (?.t * ?.t) -> bool
      val <= : (?.t * ?.t) -> bool
      val == : (?.t * ?.t) -> bool
      val > : (?.t * ?.t) -> bool
      val >= : (?.t * ?.t) -> bool
      val compare: (?.t * ?.t) -> order
      val isAlpha: ?.t -> bool
      val isAlphaNum: ?.t -> bool
      val isAscii: ?.t -> bool
      val isCntrl: ?.t -> bool
      val isDigit: ?.t -> bool
      val isGraph: ?.t -> bool
      val isHexDigit: ?.t -> bool
      val isLower: ?.t -> bool
      val isPrint: ?.t -> bool
      val isPunct: ?.t -> bool
      val isSpace: ?.t -> bool
      val isUpper: ?.t -> bool
      val ofInt: Int32.t -> ?.t
      val toInt: ?.t -> Int32.t
      val toLower: ?.t -> ?.t
      val toUpper: ?.t -> ?.t
   end
signature COMMAND_LINE = 
   sig
      val arguments: unit -> string list
      val name: unit -> string
   end
signature DATE = 
   sig
      type t = ?.t
      val format: (?.t * string) -> string
      val hour: ?.t -> Int32.t
      val isDst: ?.t -> bool option
      val localOffset: unit -> Time.t
      val make: {hour: Int32.t,
		 minute: Int32.t,
		 month: ?.Month.t,
		 monthDay: Int32.t,
		 offset: Time.t option,
		 second: Int32.t,
		 year: Int32.t}
		-> ?.t
      val minute: ?.t -> Int32.t
      val month: ?.t -> ?.Month.t
      val monthDay: ?.t -> Int32.t
      val ofString: string -> ?.t option
      val ofTimeLocal: Time.t -> ?.t
      val ofTimeUniv: Time.t -> ?.t
      val offset: ?.t -> Time.t option
      val scanner: char seq -> (?.t * char seq) option
      val second: ?.t -> Int32.t
      val toString: ?.t -> string
      val toTime: ?.t -> Time.t
      val weekDay: ?.t -> ?.WeekDay.t
      val year: ?.t -> Int32.t
      val yearDay: ?.t -> Int32.t
      structure Month:
	 sig
	    type t = ?.Month.t
	    val april: ?.Month.t
	    val august: ?.Month.t
	    val december: ?.Month.t
	    val february: ?.Month.t
	    val january: ?.Month.t
	    val july: ?.Month.t
	    val june: ?.Month.t
	    val march: ?.Month.t
	    val may: ?.Month.t
	    val november: ?.Month.t
	    val october: ?.Month.t
	    val september: ?.Month.t
	 end
      structure WeekDay:
	 sig
	    type t = ?.WeekDay.t
	    val friday: ?.WeekDay.t
	    val monday: ?.WeekDay.t
	    val saturday: ?.WeekDay.t
	    val sunday: ?.WeekDay.t
	    val thursday: ?.WeekDay.t
	    val tuesday: ?.WeekDay.t
	    val wednesday: ?.WeekDay.t
	 end
   end
signature DIR = 
   sig
      eqtype t = string
      val changeTo: string -> unit
      val create: string -> unit
      val current: unit -> string
      val openStream: string -> ?.Stream.t
      val remove: string -> unit
      structure Stream:
	 sig
	    type t = ?.Stream.t
	    val close: ?.Stream.t -> unit
	    val read: ?.Stream.t -> string option
	    val rewind: ?.Stream.t -> unit
	 end
   end
signature ENDIAN = 
   sig
      datatype t = Big | Little
   end
signature EXN = 
   sig
      type t = ?.t
      val finally: ((unit -> 'a) * (unit -> unit)) -> 'a
      val try: ((unit -> 'a) * ('a -> 'b) * (?.t -> 'b)) -> 'b
   end
signature FILE = 
   sig
      eqtype t = string
      val canAccess: (string * ?.AccessMode.t list) -> bool
      val id: string -> ?.Id.t
      val modTime: string -> Time.t
      val openIn: string -> In.t
      val openOut: string -> Out.t
      val remove: string -> unit
      val rename: {new: string, old: string} -> unit
      val setTime: (string * Time.t) -> unit
      val size: string -> Int64.t
      val temp: {prefix: string, suffix: string} -> (string * Out.t)
      val withIn: (string * (In.t -> 'a)) -> 'a
      val withOut: (string * (Out.t -> 'a)) -> 'a
      structure AccessMode:
	 sig
	    type t = ?.AccessMode.t
	    val exec: ?.AccessMode.t
	    val read: ?.AccessMode.t
	    val write: ?.AccessMode.t
	 end
      structure Id:
	 sig
	    type t = ?.Id.t
	    val == : (?.Id.t * ?.Id.t) -> bool
	    val compare: (?.Id.t * ?.Id.t) -> order
	    val hash: ?.Id.t -> Word32.t
	 end
   end
signature IN = 
   sig
      type t = ?.t
      val close: ?.t -> unit
      val get1: ?.t -> char option
      val getAll: ?.t -> string
      val getLine: ?.t -> string option
      val lines: ?.t -> string seq
      val standard: ?.t
   end
signature INT = 
   sig
      type t = ?.t
      val * : (?.t * ?.t) -> ?.t
      val + : (?.t * ?.t) -> ?.t
      val - : (?.t * ?.t) -> ?.t
      val < : (?.t * ?.t) -> bool
      val <= : (?.t * ?.t) -> bool
      val == : (?.t * ?.t) -> bool
      val > : (?.t * ?.t) -> bool
      val >= : (?.t * ?.t) -> bool
      val compare: (?.t * ?.t) -> order
      val div: (?.t * ?.t) -> ?.t
      val fold: (?.t * ?.t * 'a * ((?.t * 'a) -> 'a)) -> 'a
      val foldDown: (?.t * ?.t * 'a * ((?.t * 'a) -> 'a)) -> 'a
      val for: (?.t * ?.t * (?.t -> unit)) -> unit
      val fromTo: (?.t * ?.t) -> ?.t seq
      val fromToBy: (?.t * ?.t * ?.t) -> ?.t seq
      val geu: (?.t * ?.t) -> bool
      val mod: (?.t * ?.t) -> ?.t
      val ofString: string -> ?.t option
      val ofStringRadix: (string * Radix.t) -> ?.t option
      val quot: (?.t * ?.t) -> ?.t
      val rem: (?.t * ?.t) -> ?.t
      val scanner: Radix.t -> (char seq -> (?.t * char seq) option)
      val toString: ?.t -> string
      val toStringRadix: (?.t * Radix.t) -> string
      val toWord: ?.t -> Word32.t
   end
signature INT_INF = 
   sig
      type t = ?.t
      val * : (?.t * ?.t) -> ?.t
      val + : (?.t * ?.t) -> ?.t
      val - : (?.t * ?.t) -> ?.t
      val < : (?.t * ?.t) -> bool
      val <= : (?.t * ?.t) -> bool
      val == : (?.t * ?.t) -> bool
      val > : (?.t * ?.t) -> bool
      val >= : (?.t * ?.t) -> bool
      val compare: (?.t * ?.t) -> order
      val div: (?.t * ?.t) -> ?.t
      val fold: (?.t * ?.t * 'a * ((?.t * 'a) -> 'a)) -> 'a
      val foldDown: (?.t * ?.t * 'a * ((?.t * 'a) -> 'a)) -> 'a
      val for: (?.t * ?.t * (?.t -> unit)) -> unit
      val fromTo: (?.t * ?.t) -> ?.t seq
      val fromToBy: (?.t * ?.t * ?.t) -> ?.t seq
      val geu: (?.t * ?.t) -> bool
      val mod: (?.t * ?.t) -> ?.t
      val ofString: string -> ?.t option
      val ofStringRadix: (string * Radix.t) -> ?.t option
      val quot: (?.t * ?.t) -> ?.t
      val rem: (?.t * ?.t) -> ?.t
      val scanner: Radix.t -> (char seq -> (?.t * char seq) option)
      val toString: ?.t -> string
      val toStringRadix: (?.t * Radix.t) -> string
      val toWord: ?.t -> Word32.t
   end
signature IO_DESC = 
   sig
      type t = ?.t
      val compare: (?.t * ?.t) -> order
      val hash: ?.t -> Word32.t
      structure Kind:
	 sig
	    type t = ?.Kind.t
	    val == : (?.Kind.t * ?.Kind.t) -> bool
	    val device: ?.Kind.t
	    val dir: ?.Kind.t
	    val file: ?.Kind.t
	    val pipe: ?.Kind.t
	    val socket: ?.Kind.t
	    val symlink: ?.Kind.t
	    val tty: ?.Kind.t
	 end
   end
signature LAZY = 
   sig
      val memo: (unit -> 'a) -> (unit -> 'a)
   end
signature LIST = 
   sig
      type 'a elem = 'a ?.elem
      datatype 'a t = nil | :: of 'a * 'a list
      eqtype 'a t0 = 'a list
      type 'a unfold = 'a ?.unfold
      type 'a unfoldR = 'a ?.unfoldR
      val all: ('a list * ('a ?.elem -> bool)) -> bool
      val append: ('a list * 'a list) -> 'a list
      val concat: 'a list seq -> 'a list
      val cons: ('a ?.elem * 'a list) -> 'a list
      val drop: ('a list * ('a ?.elem -> bool)) -> 'a list
      val dropPrefix: ('a list * ('a ?.elem -> bool)) -> 'a list
      val dropPrefixN: ('a list * Int32.t) -> 'a list
      val dropSuffix: ('a list * ('a ?.elem -> bool)) -> 'a list
      val dropSuffixN: ('a list * Int32.t) -> 'a list
      val empty: unit -> 'a list
      val exists: ('a list * ('a ?.elem -> bool)) -> bool
      val fields: ('a list * ('a ?.elem -> bool)) -> 'a list seq
      val find: ('a list * ('a ?.elem -> bool)) -> 'a ?.elem option
      val fold: ('a list * 'b * (('a ?.elem * 'b) -> 'b)) -> 'b
      val for: ('a list * ('a ?.elem -> unit)) -> unit
      val isEmpty: 'a list -> bool
      val join: ('a list seq * 'a list) -> 'a list
      val keep: ('a list * ('a ?.elem -> bool)) -> 'a list
      val keepPrefix: ('a list * ('a ?.elem -> bool)) -> 'a list
      val keepPrefixN: ('a list * Int32.t) -> 'a list
      val keepSuffix: ('a list * ('a ?.elem -> bool)) -> 'a list
      val keepSuffixN: ('a list * Int32.t) -> 'a list
      val last: 'a list -> 'a ?.elem
      val map: ('a list * ('a ?.elem -> 'b ?.elem)) -> 'b list
      val ofSeq: 'a ?.elem seq -> 'a list
      val ofSeqN: ('a ?.elem seq * Int32.t) -> 'a list
      val recur: ('a list
		  * 'b
		  * ('b -> 'c)
		  * (('a ?.elem * 'b * ('b -> 'c)) -> 'c))
		 -> 'c
      val reverse: 'a list -> 'a list
      val separate: ('a list * 'a ?.elem) -> 'a list
      val single: 'a ?.elem -> 'a list
      val size: 'a list -> Int32.t
      val splitPrefix: ('a list * ('a ?.elem -> bool)) -> ('a list * 'a list)
      val sub: ('a list * Int32.t) -> 'a ?.elem
      val tabulate: (Int32.t * (Int32.t -> 'a ?.elem)) -> 'a list
      val toSeq: 'a list -> 'a ?.elem seq
      val toSeqR: 'a list -> 'a ?.elem seq
      val tokens: ('a list * ('a ?.elem -> bool)) -> 'a list seq
      val unfold: ('a * ('a -> ('b ?.elem * 'a) option))
		  -> ('b list * 'a ?.unfold)
      val unfoldN: (Int32.t * 'a * ((Int32.t * 'a) -> ('b ?.elem * 'a) option))
		   -> ('b list * 'a ?.unfold)
      val unfoldNR: (Int32.t * 'a * ((Int32.t * 'a) -> ('b ?.elem * 'a) option))
		    -> ('b list * 'a ?.unfoldR)
      val unfoldR: ('a * ('a -> ('b ?.elem * 'a) option))
		   -> ('b list * 'a ?.unfoldR)
   end
signature NET = 
   sig
      val getHostName: unit -> string
      structure Family:
	 sig
	    type inet = ?.Family.inet
	    type 'a t = 'a ?.Family.t
	    type unix = ?.Family.unix
	    type unknown = ?.Family.unknown
	    val == : ('a ?.Family.t * 'a ?.Family.t) -> bool
	    val all: unit
		     -> (?.Family.unknown ?.Family.t * {name: string}) ?.vector
	    val inet: ?.Family.inet ?.Family.t
	    val ofString: string -> ?.Family.unknown ?.Family.t option
	    val toString: 'a ?.Family.t -> string
	    val unix: ?.Family.unix ?.Family.t
	 end
      structure Host:
	 sig
	    type t = ?.Host.t
	    val address: ?.Host.t -> ?.Host.Address.t
	    val addresses: ?.Host.t -> ?.Host.Address.t ?.vector
	    val aliases: ?.Host.t -> string ?.vector
	    val family: ?.Host.t -> ?.Family.unknown ?.Family.t
	    val getByAddress: ?.Host.Address.t -> ?.Host.t option
	    val getByName: string -> ?.Host.t option
	    val name: ?.Host.t -> string
	    structure Address:
	       sig
		  type t = ?.Host.Address.t
		  val == : (?.Host.Address.t * ?.Host.Address.t) -> bool
		  val ofString: string -> ?.Host.Address.t option
		  val scanner: char seq -> (?.Host.Address.t * char seq) option
		  val toString: ?.Host.Address.t -> string
	       end
	 end
      structure Protocol:
	 sig
	    type t = ?.Protocol.t
	    val aliases: ?.Protocol.t -> string ?.vector
	    val getByName: string -> ?.Protocol.t option
	    val getByNumber: Int32.t -> ?.Protocol.t option
	    val name: ?.Protocol.t -> string
	    val number: ?.Protocol.t -> Int32.t
	 end
      structure Service:
	 sig
	    type t = ?.Service.t
	    val aliases: ?.Service.t -> string ?.vector
	    val getByName: (string * string option) -> ?.Service.t option
	    val getByPort: (Int32.t * string option) -> ?.Service.t option
	    val name: ?.Service.t -> string
	    val port: ?.Service.t -> Int32.t
	    val protocol: ?.Service.t -> string
	 end
      structure Socket:
	 sig
	    type ('a, 'b) sock = ('a, 'b) ?.Socket.sock
	    type ('a, 'b) t = ('a, 'b) ?.Socket.sock
	    val accept: (('a, ?.Socket.Type.passive ?.Socket.Type.stream) ?.Socket.sock
			 * ((('a, ?.Socket.Type.active ?.Socket.Type.stream) ?.Socket.sock
			     * 'a ?.Socket.Address.t),
			    (('a, ?.Socket.Type.active ?.Socket.Type.stream) ?.Socket.sock
			     * 'a ?.Socket.Address.t) option,
			    'b) ?.Socket.Block.t)
			-> 'b
	    val bind: (('a, 'b) ?.Socket.sock * 'a ?.Socket.Address.t) -> unit
	    val close: ('a, 'b) ?.Socket.sock -> unit
	    val connect: (('a, 'b) ?.Socket.sock
			  * 'a ?.Socket.Address.t
			  * (unit, unit option, 'c) ?.Socket.Block.t)
			 -> 'c
	    val desc: ('a, 'b) ?.Socket.sock -> ?.Socket.Desc.t
	    val getOption: (('a, 'b) ?.Socket.sock
			    * ('c, 'a, 'b, 'd) ?.Socket.Option.t)
			   -> 'c
	    val ioDesc: ('a, 'b) ?.Socket.sock -> Int32.t
	    val listen: (('a, ?.Socket.Type.passive ?.Socket.Type.stream) ?.Socket.sock
			 * Int32.t)
			-> unit
	    val make: ('a ?.Family.t
		       * 'b ?.Socket.Type.t
		       * {protocol: Int32.t} option)
		      -> ('a, 'b) ?.Socket.sock
	    val makePair: ('a ?.Family.t
			   * 'b ?.Socket.Type.t
			   * {protocol: Int32.t} option)
			  -> (('a, 'b) ?.Socket.sock * ('a, 'b) ?.Socket.sock)
	    val myAddress: ('a, 'b) ?.Socket.sock -> 'a ?.Socket.Address.t
	    val peerAddress: ('a, 'b) ?.Socket.sock -> 'a ?.Socket.Address.t
	    val select: {exs: ?.Socket.Desc.t list,
			 rds: ?.Socket.Desc.t list,
			 timeout: Time.t option,
			 wrs: ?.Socket.Desc.t list}
			-> {exs: ?.Socket.Desc.t list,
			    rds: ?.Socket.Desc.t list,
			    wrs: ?.Socket.Desc.t list}
	    val setOption: (('a, 'b) ?.Socket.sock
			    * ('c, 'a, 'b, ?.Socket.Option.rw) ?.Socket.Option.t
			    * 'c)
			   -> unit
	    val shutdown: (('a, 'b ?.Socket.Type.stream) ?.Socket.sock
			   * ?.Socket.ShutdownMode.t)
			  -> unit
	    structure Address:
	       sig
		  type 'a t = 'a ?.Socket.Address.t
		  val == : ('a ?.Socket.Address.t * 'a ?.Socket.Address.t)
			   -> bool
		  val family: 'a ?.Socket.Address.t -> 'a ?.Family.t
		  val inet: {port: Int32.t} -> ?.Family.inet ?.Socket.Address.t
		  val ofHost: (?.Host.Address.t * {port: Int32.t})
			      -> ?.Family.inet ?.Socket.Address.t
		  val ofUnix: string -> ?.Family.unix ?.Socket.Address.t
		  val toHost: ?.Family.inet ?.Socket.Address.t
			      -> (?.Host.Address.t * {port: Int32.t})
		  val toUnix: ?.Family.unix ?.Socket.Address.t -> string
	       end
	    structure Block:
	       sig
		  type ('a, 'b, 'c) t = ('a, 'b, 'c) ?.Socket.Block.t
		  type ('a, 'b) u = ('a, 'a option, 'b) ?.Socket.Block.t
		  val may: ('a, 'b, 'a) ?.Socket.Block.t
		  val non: ('a, 'b, 'b) ?.Socket.Block.t
	       end
	    structure Desc:
	       sig
		  type t = ?.Socket.Desc.t
		  val == : (?.Socket.Desc.t * ?.Socket.Desc.t) -> bool
	       end
	    structure Option:
	       sig
		  type ro = ?.Socket.Option.ro
		  type rw = ?.Socket.Option.rw
		  type ('a, 'b, 'c, 'd) t = ('a, 'b, 'c, 'd) ?.Socket.Option.t
		  val atmark: (bool,
			       'a,
			       ?.Socket.Type.active ?.Socket.Type.stream,
			       ?.Socket.Option.ro) ?.Socket.Option.t
		  val broadcast: (bool, 'a, 'b, ?.Socket.Option.rw) ?.Socket.Option.t
		  val debug: (bool, 'a, 'b, ?.Socket.Option.rw) ?.Socket.Option.t
		  val dontRoute: (bool, 'a, 'b, ?.Socket.Option.rw) ?.Socket.Option.t
		  val error: (bool, 'a, 'b, ?.Socket.Option.ro) ?.Socket.Option.t
		  val keepAlive: (bool, 'a, 'b, ?.Socket.Option.rw) ?.Socket.Option.t
		  val linger: (Time.t option, 'a, 'b, ?.Socket.Option.rw) ?.Socket.Option.t
		  val nRead: (Int32.t, 'a, 'b, ?.Socket.Option.ro) ?.Socket.Option.t
		  val noDelay: (bool,
				?.Family.inet,
				'a ?.Socket.Type.stream,
				?.Socket.Option.rw) ?.Socket.Option.t
		  val oobInline: (bool, 'a, 'b, ?.Socket.Option.rw) ?.Socket.Option.t
		  val rcvBuf: (Int32.t, 'a, 'b, ?.Socket.Option.rw) ?.Socket.Option.t
		  val reuseAddr: (bool, 'a, 'b, ?.Socket.Option.rw) ?.Socket.Option.t
		  val sndBuf: (Int32.t, 'a, 'b, ?.Socket.Option.rw) ?.Socket.Option.t
		  val ty: (?.Socket.Type.unknown ?.Socket.Type.t,
			   'a,
			   'b,
			   ?.Socket.Option.ro) ?.Socket.Option.t
	       end
	    structure Receive:
	       sig
		  val receive: (('a, 'b, 'c, 'd) ?.Socket.Receive.From.t
				* ('a, 'e, 'f, 'g, 'h, 'b, 'c) ?.Socket.Receive.To.t
				* ('a,
				   (Int32.t * 'a ?.Socket.Address.t),
				   Int32.t,
				   (Word8.t ?.vector * 'a ?.Socket.Address.t),
				   Word8.t ?.vector,
				   'e,
				   'f,
				   'g,
				   'h) ?.Socket.Receive.Block.t
				* ?.Socket.Receive.Flag.t list)
			       -> 'd
		  structure Block:
		     sig
			type ('a, 'b, 'c, 'd, 'e, 'f, 'g, 'h, 'i) t = ('a,
								       'b,
								       'c,
								       'd,
								       'e,
								       'f,
								       'g,
								       'h,
								       'i) ?.Socket.Receive.Block.t
			val may: ('a, 'b, 'c, 'd, 'e, 'b, 'c, 'd, 'e) ?.Socket.Receive.Block.t
			val non: ('a,
				  'b,
				  'c,
				  'd,
				  'e,
				  'b option,
				  'c option,
				  'd option,
				  'e option) ?.Socket.Receive.Block.t
		     end
		  structure Flag:
		     sig
			type t = ?.Socket.Receive.Flag.t
			val outOfBand: ?.Socket.Receive.Flag.t
			val peek: ?.Socket.Receive.Flag.t
		     end
		  structure From:
		     sig
			type ('a, 'b, 'c, 'd) t = ('a, 'b, 'c, 'd) ?.Socket.Receive.From.t
			val dgram: ('a, ?.Socket.Type.dgram) ?.Socket.sock
				   -> ('a, 'b, 'c, 'b) ?.Socket.Receive.From.t
			val stream: ('a,
				     ?.Socket.Type.active ?.Socket.Type.stream) ?.Socket.sock
				    -> ('a, 'b, 'c, 'c) ?.Socket.Receive.From.t
		     end
		  structure To:
		     sig
			type ('a, 'b, 'c, 'd, 'e, 'f, 'g) t = ('a,
							       'b,
							       'c,
							       'd,
							       'e,
							       'f,
							       'g) ?.Socket.Receive.To.t
			val array: Word8.t ?.Sequence.Slice.t
				   -> ('a, 'b, 'c, 'd, 'e, 'b, 'c) ?.Socket.Receive.To.t
			val vector: {numBytes: Int32.t}
				    -> ('a, 'b, 'c, 'd, 'e, 'd, 'e) ?.Socket.Receive.To.t
		     end
	       end
	    structure Send:
	       sig
		  val send: (?.Socket.Send.From.t
			     * ('a, 'b, 'c, 'd) ?.Socket.Send.To.t
			     * ('a, unit, Int32.t, bool, Int32.t option, 'b, 'c) ?.Socket.Send.Block.t
			     * ?.Socket.Send.Flag.t list)
			    -> 'd
		  structure Block:
		     sig
			type ('a, 'b, 'c, 'd, 'e, 'f, 'g) t = ('a,
							       'b,
							       'c,
							       'd,
							       'e,
							       'f,
							       'g) ?.Socket.Send.Block.t
			val may: ('a, 'b, 'c, 'd, 'e, 'b, 'c) ?.Socket.Send.Block.t
			val non: ('a, 'b, 'c, 'd, 'e, 'd, 'e) ?.Socket.Send.Block.t
		     end
		  structure Flag:
		     sig
			type t = ?.Socket.Send.Flag.t
			val dontRoute: ?.Socket.Send.Flag.t
			val outOfBand: ?.Socket.Send.Flag.t
		     end
		  structure From:
		     sig
			type t = ?.Socket.Send.From.t
			val array: Word8.t ?.Sequence.Slice.t
				   -> ?.Socket.Send.From.t
			val vector: Word8.t ?.Sequence.Slice.t
				    -> ?.Socket.Send.From.t
		     end
		  structure To:
		     sig
			type ('a, 'b, 'c, 'd) t = ('a, 'b, 'c, 'd) ?.Socket.Send.To.t
			val dgram: (('a, ?.Socket.Type.dgram) ?.Socket.sock
				    * 'a ?.Socket.Address.t)
				   -> ('a, 'b, 'c, 'b) ?.Socket.Send.To.t
			val stream: ('a,
				     ?.Socket.Type.active ?.Socket.Type.stream) ?.Socket.sock
				    -> ('a, 'b, 'c, 'c) ?.Socket.Send.To.t
		     end
	       end
	    structure ShutdownMode:
	       sig
		  type t = ?.Socket.ShutdownMode.t
		  val noRecvs: ?.Socket.ShutdownMode.t
		  val noRecvsSends: ?.Socket.ShutdownMode.t
		  val noSends: ?.Socket.ShutdownMode.t
	       end
	    structure Type:
	       sig
		  type active = ?.Socket.Type.active
		  type activeStream = ?.Socket.Type.active ?.Socket.Type.stream
		  type dgram = ?.Socket.Type.dgram
		  type passive = ?.Socket.Type.passive
		  type passiveStream = ?.Socket.Type.passive ?.Socket.Type.stream
		  type 'a stream = 'a ?.Socket.Type.stream
		  type 'a t = 'a ?.Socket.Type.t
		  type unknown = ?.Socket.Type.unknown
		  val == : ('a ?.Socket.Type.t * 'a ?.Socket.Type.t) -> bool
		  val all: unit
			   -> (?.Socket.Type.unknown ?.Socket.Type.t
			       * {name: string}) ?.vector
		  val dgram: ?.Socket.Type.dgram ?.Socket.Type.t
		  val ofString: string
				-> ?.Socket.Type.unknown ?.Socket.Type.t option
		  val stream: 'a ?.Socket.Type.stream ?.Socket.Type.t
		  val toString: 'a ?.Socket.Type.t -> string
	       end
	 end
   end
signature OPTION = 
   sig
      datatype 'a t = None | Some of 'a
      val isNone: 'a ?.t -> bool
      val isSome: 'a ?.t -> bool
      val map: ('a ?.t * ('a -> 'b)) -> 'b ?.t
      val toSeq: 'a ?.t -> 'a seq
      val valOf: 'a ?.t -> 'a
   end
signature ORDER = 
   sig
      datatype t = Equal | Greater | Less
   end
signature OUT = 
   sig
      type t = ?.t
      val close: ?.t -> unit
      val error: ?.t
      val flush: ?.t -> unit
      val newline: ?.t -> unit
      val put: (?.t * string) -> unit
      val put1: (?.t * char) -> unit
      val puts: (?.t * string seq) -> unit
      val standard: ?.t
   end
signature PACKABLE_REAL = 
   sig
      type t = ?.t
      val != : (?.t * ?.t) -> bool
      val * : (?.t * ?.t) -> ?.t
      val + : (?.t * ?.t) -> ?.t
      val - : (?.t * ?.t) -> ?.t
      val / : (?.t * ?.t) -> ?.t
      val < : (?.t * ?.t) -> bool
      val <= : (?.t * ?.t) -> bool
      val == : (?.t * ?.t) -> bool
      val > : (?.t * ?.t) -> bool
      val >= : (?.t * ?.t) -> bool
      val ?= : (?.t * ?.t) -> bool
      val abs: ?.t -> ?.t
      val acos: ?.t -> ?.t
      val asin: ?.t -> ?.t
      val atan: ?.t -> ?.t
      val atan2: (?.t * ?.t) -> ?.t
      val ceil: ?.t -> Int32.t
      val checkFloat: ?.t -> ?.t
      val class: ?.t -> ?.Class.t
      val compare: (?.t * ?.t) -> order
      val copySign: (?.t * ?.t) -> ?.t
      val cos: ?.t -> ?.t
      val cosh: ?.t -> ?.t
      val e: ?.t
      val exp: ?.t -> ?.t
      val floor: ?.t -> Int32.t
      val format: (?.t * ?.Format.t) -> string
      val isFinite: ?.t -> bool
      val isNan: ?.t -> bool
      val isNormal: ?.t -> bool
      val ln: ?.t -> ?.t
      val log10: ?.t -> ?.t
      val max: (?.t * ?.t) -> ?.t
      val maxFinite: ?.t
      val min: (?.t * ?.t) -> ?.t
      val minNormalPos: ?.t
      val minPos: ?.t
      val negInf: ?.t
      val nextAfter: (?.t * ?.t) -> ?.t
      val ofBytes: (Word8.t ?.vector * ?.Endian.t) -> ?.t
      val ofDecimal: {class: ?.Class.t,
		      digits: Int32.t list,
		      exp: Int32.t,
		      sign: bool}
		     -> ?.t option
      val ofInt: Int32.t -> ?.t
      val ofLarge: (Real64.t * ?.RoundingMode.t) -> ?.t
      val ofLargeInt: IntInf.t -> ?.t
      val ofManExp: {exp: Int32.t, man: ?.t} -> ?.t
      val ofString: string -> ?.t option
      val pi: ?.t
      val posInf: ?.t
      val pow: (?.t * ?.t) -> ?.t
      val precision: Int32.t
      val radix: Int32.t
      val realCeil: ?.t -> ?.t
      val realFloor: ?.t -> ?.t
      val realMod: ?.t -> ?.t
      val realRound: ?.t -> ?.t
      val realTrunc: ?.t -> ?.t
      val rem: (?.t * ?.t) -> ?.t
      val round: ?.t -> Int32.t
      val sameSign: (?.t * ?.t) -> bool
      val scanner: char seq -> (?.t * char seq) option
      val sign: ?.t -> Int32.t
      val signBit: ?.t -> bool
      val sin: ?.t -> ?.t
      val sinh: ?.t -> ?.t
      val split: ?.t -> {frac: ?.t, whole: ?.t}
      val sqrt: ?.t -> ?.t
      val subArr: (Word8.t ?.array * Int32.t * ?.Endian.t) -> ?.t
      val subVec: (Word8.t ?.vector * Int32.t * ?.Endian.t) -> ?.t
      val tan: ?.t -> ?.t
      val tanh: ?.t -> ?.t
      val toBytes: (?.t * ?.Endian.t) -> Word8.t ?.vector
      val toDecimal: ?.t
		     -> {class: ?.Class.t,
			 digits: Int32.t list,
			 exp: Int32.t,
			 sign: bool}
      val toInt: (?.t * ?.RoundingMode.t) -> Int32.t
      val toLarge: ?.t -> Real64.t
      val toLargeInt: (?.t * ?.RoundingMode.t) -> IntInf.t
      val toManExp: ?.t -> {exp: Int32.t, man: ?.t}
      val toString: ?.t -> string
      val trunc: ?.t -> Int32.t
      val unordered: (?.t * ?.t) -> bool
      val update: (Word8.t ?.array * Int32.t * ?.t * ?.Endian.t) -> unit
      val ~ : ?.t -> ?.t
      structure Class:
	 sig
	    datatype t = Inf | Nan | Normal | Subnormal | Zero
	 end
      structure Decimal:
	 sig
	    eqtype t = {class: ?.Class.t,
			digits: Int32.t list,
			exp: Int32.t,
			sign: bool}
	    val ofString: string
			  -> {class: ?.Class.t,
			      digits: Int32.t list,
			      exp: Int32.t,
			      sign: bool} option
	    val scanner: char seq
			 -> ({class: ?.Class.t,
			      digits: Int32.t list,
			      exp: Int32.t,
			      sign: bool}
			     * char seq) option
	    val toString: {class: ?.Class.t,
			   digits: Int32.t list,
			   exp: Int32.t,
			   sign: bool}
			  -> string
	 end
      structure Format:
	 sig
	    type t = ?.Format.t
	    val exact: ?.Format.t
	    val fix: Int32.t -> ?.Format.t
	    val gen: Int32.t -> ?.Format.t
	    val sci: Int32.t -> ?.Format.t
	 end
      structure RoundingMode:
	 sig
	    type t = ?.RoundingMode.t
	    val get: unit -> ?.RoundingMode.t
	    val nearest: ?.RoundingMode.t
	    val negInf: ?.RoundingMode.t
	    val posInf: ?.RoundingMode.t
	    val set: ?.RoundingMode.t -> unit
	    val zero: ?.RoundingMode.t
	 end
   end
signature PACKABLE_WORD = 
   sig
      type t = ?.t
      val * : (?.t * ?.t) -> ?.t
      val + : (?.t * ?.t) -> ?.t
      val - : (?.t * ?.t) -> ?.t
      val < : (?.t * ?.t) -> bool
      val << : (?.t * Word32.t) -> ?.t
      val <= : (?.t * ?.t) -> bool
      val == : (?.t * ?.t) -> bool
      val > : (?.t * ?.t) -> bool
      val >= : (?.t * ?.t) -> bool
      val >> : (?.t * Word32.t) -> ?.t
      val andb: (?.t * ?.t) -> ?.t
      val compare: (?.t * ?.t) -> order
      val div: (?.t * ?.t) -> ?.t
      val mod: (?.t * ?.t) -> ?.t
      val notb: ?.t -> ?.t
      val ofLarge: Word64.t -> ?.t
      val ofString: string -> ?.t option
      val ofStringRadix: (string * Radix.t) -> ?.t option
      val orb: (?.t * ?.t) -> ?.t
      val scanner: Radix.t -> (char seq -> (?.t * char seq) option)
      val subArr: (Word8.t ?.array * Int32.t * ?.Endian.t) -> ?.t
      val subVec: (Word8.t ?.vector * Int32.t * ?.Endian.t) -> ?.t
      val toLarge: ?.t -> Word64.t
      val toLargeX: ?.t -> Word64.t
      val toString: ?.t -> string
      val toStringRadix: (?.t * Radix.t) -> string
      val update: (Word8.t ?.array * Int32.t * ?.t * ?.Endian.t) -> unit
      val xorb: (?.t * ?.t) -> ?.t
      val ~>> : (?.t * Word32.t) -> ?.t
   end
signature PATH = 
   sig
      eqtype t = string
      val append: (string * string) -> string
      val base: string -> string
      val dir: string -> string
      val ext: string -> string option
      val file: string -> string
      val full: string -> string
      val getParent: string -> string
      val getVolume: string -> string
      val isAbsolute: string -> bool
      val isCanonical: string -> bool
      val isDir: string -> bool
      val isLink: string -> bool
      val isRelative: string -> bool
      val isRoot: string -> bool
      val joinBaseExt: {base: string, ext: string option} -> string
      val joinDirFile: {dir: string, file: string} -> string
      val mkAbsolute: (string * {relativeTo: string}) -> string
      val mkCanonical: string -> string
      val mkRelative: (string * {relativeTo: string}) -> string
      val ofPieces: ?.Pieces.t -> string
      val ofUnix: string -> string
      val readLink: string -> string
      val real: string -> string
      val splitBaseExt: string -> {base: string, ext: string option}
      val splitDirFile: string -> {dir: string, file: string}
      val toPieces: string -> ?.Pieces.t
      val toUnix: string -> string
      structure Arc:
	 sig
	    eqtype t = string
	    val current: string
	    val parent: string
	 end
      structure Pieces:
	 sig
	    datatype t = T of {arcs: string list, isAbs: bool, volume: string}
	 end
      structure Volume:
	 sig
	    eqtype t = string
	    val isValid: (string * {isAbs: bool}) -> bool
	 end
   end
signature POLL = 
   sig
      val poll: (?.Desc.t list * Time.t option) -> ?.Info.t list
      structure Desc:
	 sig
	    type t = ?.Desc.t
	    exception Poll
	    val addIn: ?.Desc.t -> ?.Desc.t
	    val addOut: ?.Desc.t -> ?.Desc.t
	    val addPri: ?.Desc.t -> ?.Desc.t
	    val ofIO: Int32.t -> ?.Desc.t option
	    val toIO: ?.Desc.t -> Int32.t
	 end
      structure Info:
	 sig
	    type t = ?.Info.t
	    val isIn: ?.Info.t -> bool
	    val isOut: ?.Info.t -> bool
	    val isPri: ?.Info.t -> bool
	    val toDesc: ?.Info.t -> ?.Desc.t
	 end
   end
signature POSIX = 
   sig
      val access: (string * ?.AccessMode.t list) -> bool
      val alarm: Time.t -> Time.t
      val cfgetispeed: ?.Termios.t -> ?.Termios.Speed.t
      val cfgetospeed: ?.Termios.t -> ?.Termios.Speed.t
      val cfsetispeed: (?.Termios.t * ?.Termios.Speed.t) -> ?.Termios.t
      val cfsetospeed: (?.Termios.t * ?.Termios.Speed.t) -> ?.Termios.t
      val chdir: string -> unit
      val chmod: (string * ?.Mode.t) -> unit
      val chown: (string * ?.Uid.t * ?.Gid.t) -> unit
      val close: ?.FileDesc.t -> unit
      val closedir: ?.DirStream.t -> unit
      val creat: (string * ?.Mode.t) -> ?.FileDesc.t
      val createf: (string * ?.OpenMode.t * ?.OpenFlags.t * ?.Mode.t)
		   -> ?.FileDesc.t
      val ctermid: unit -> string
      val dup: ?.FileDesc.t -> ?.FileDesc.t
      val dup2: {new: ?.FileDesc.t, old: ?.FileDesc.t} -> unit
      val environ: unit -> string list
      val exec: (string * string list) -> 'a
      val exece: (string * string list * string list) -> 'a
      val execp: (string * string list) -> 'a
      val exit: Word8.t -> 'a
      val fchmod: (?.FileDesc.t * ?.Mode.t) -> unit
      val fchown: (?.FileDesc.t * ?.Uid.t * ?.Gid.t) -> unit
      val fcntl: (?.FileDesc.t * ('a, 'b) ?.Fcntl.t * 'a) -> 'b
      val fork: unit -> ?.Pid.t option
      val fpathconf: (?.FileDesc.t * string) -> Word64.t option
      val fstat: ?.FileDesc.t -> ?.Stat.t
      val fsync: ?.FileDesc.t -> unit
      val ftruncate: (?.FileDesc.t * Int64.t) -> unit
      val getcwd: unit -> string
      val getegid: unit -> ?.Gid.t
      val getenv: string -> string option
      val geteuid: unit -> ?.Uid.t
      val getgid: unit -> ?.Gid.t
      val getgrgid: ?.Gid.t -> ?.Group.t
      val getgrnam: string -> ?.Group.t
      val getgroups: unit -> ?.Gid.t list
      val getlogin: unit -> string
      val getpgrp: unit -> ?.Pid.t
      val getpid: unit -> ?.Pid.t
      val getppid: unit -> ?.Pid.t
      val getpwnam: string -> ?.Passwd.t
      val getpwuid: ?.Uid.t -> ?.Passwd.t
      val getuid: unit -> ?.Uid.t
      val isatty: ?.FileDesc.t -> bool
      val kill: (?.KillArg.t * ?.Signal.t) -> unit
      val link: {new: string, old: string} -> unit
      val lseek: (?.FileDesc.t * Int64.t * ?.Whence.t) -> Int64.t
      val lstat: string -> ?.Stat.t
      val mkdir: (string * ?.Mode.t) -> unit
      val mkfifo: (string * ?.Mode.t) -> unit
      val opendir: string -> ?.DirStream.t
      val openf: (string * ?.OpenMode.t * ?.OpenFlags.t) -> ?.FileDesc.t
      val pathconf: (string * string) -> Word64.t option
      val pause: unit -> unit
      val pipe: unit -> {infd: ?.FileDesc.t, outfd: ?.FileDesc.t}
      val readArr: (?.FileDesc.t * Word8.t ?.Sequence.Slice.t) -> Int32.t
      val readVec: (?.FileDesc.t * Int32.t) -> Word8.t ?.vector
      val readdir: ?.DirStream.t -> string option
      val readlink: string -> string
      val rename: {new: string, old: string} -> unit
      val rewinddir: ?.DirStream.t -> unit
      val rmdir: string -> unit
      val setgid: ?.Gid.t -> unit
      val setpgid: {pgid: ?.Pid.t option, pid: ?.Pid.t option} -> unit
      val setsid: unit -> ?.Pid.t
      val setuid: ?.Uid.t -> unit
      val sleep: Time.t -> Time.t
      val stat: string -> ?.Stat.t
      val symlink: {new: string, old: string} -> unit
      val sysconf: string -> Word64.t
      val tcdrain: ?.FileDesc.t -> unit
      val tcflow: (?.FileDesc.t * ?.FlowAction.t) -> unit
      val tcflush: (?.FileDesc.t * ?.QueueSel.t) -> unit
      val tcgetattr: ?.FileDesc.t -> ?.Termios.t
      val tcgetpgrp: ?.FileDesc.t -> ?.Pid.t
      val tcsendbreak: (?.FileDesc.t * Int32.t) -> unit
      val tcsetattr: (?.FileDesc.t * ?.SetAction.t * ?.Termios.t) -> unit
      val tcsetpgrp: (?.FileDesc.t * ?.Pid.t) -> unit
      val time: unit -> Time.t
      val times: unit
		 -> {cstime: Time.t,
		     cutime: Time.t,
		     elapsed: Time.t,
		     stime: Time.t,
		     utime: Time.t}
      val ttyname: ?.FileDesc.t -> string
      val umask: ?.Mode.t -> ?.Mode.t
      val uname: unit -> (string * string) list
      val unlink: string -> unit
      val utime: (string * {actime: Time.t, modtime: Time.t} option) -> unit
      val wait: unit -> (?.Pid.t * ?.ExitStatus.t)
      val waitpid: (?.WaitPidArg.t * ?.WaitPidFlags.t list)
		   -> (?.Pid.t * ?.ExitStatus.t)
      val waitpidNohang: (?.WaitPidArg.t * ?.WaitPidFlags.t list)
			 -> (?.Pid.t * ?.ExitStatus.t) option
      val writeArr: (?.FileDesc.t * Word8.t ?.Sequence.Slice.t) -> Int32.t
      val writeVec: (?.FileDesc.t * Word8.t ?.Sequence.Slice.t) -> Int32.t
      structure AccessMode:
	 sig
	    type t = ?.AccessMode.t
	    val exec: ?.AccessMode.t
	    val read: ?.AccessMode.t
	    val write: ?.AccessMode.t
	 end
      structure Dev:
	 sig
	    type t = ?.Dev.t
	    val ofWord: Word64.t -> ?.Dev.t
	    val toWord: ?.Dev.t -> Word64.t
	 end
      structure DirStream:
	 sig
	    type t = ?.DirStream.t
	 end
      structure Error:
	 sig
	    type t = ?.Error.t
	    val acces: ?.Error.t
	    val again: ?.Error.t
	    val badf: ?.Error.t
	    val badmsg: ?.Error.t
	    val busy: ?.Error.t
	    val canceled: ?.Error.t
	    val child: ?.Error.t
	    val deadlk: ?.Error.t
	    val dom: ?.Error.t
	    val exist: ?.Error.t
	    val fault: ?.Error.t
	    val fbig: ?.Error.t
	    val inprogress: ?.Error.t
	    val intr: ?.Error.t
	    val inval: ?.Error.t
	    val io: ?.Error.t
	    val isdir: ?.Error.t
	    val loop: ?.Error.t
	    val message: ?.Error.t -> string
	    val mfile: ?.Error.t
	    val mlink: ?.Error.t
	    val msgsize: ?.Error.t
	    val name: ?.Error.t -> string
	    val nametoolong: ?.Error.t
	    val nfile: ?.Error.t
	    val nodev: ?.Error.t
	    val noent: ?.Error.t
	    val noexec: ?.Error.t
	    val nolck: ?.Error.t
	    val nomem: ?.Error.t
	    val nospc: ?.Error.t
	    val nosys: ?.Error.t
	    val notdir: ?.Error.t
	    val notempty: ?.Error.t
	    val notsup: ?.Error.t
	    val notty: ?.Error.t
	    val nxio: ?.Error.t
	    val ofName: string -> ?.Error.t option
	    val ofWord: Word64.t -> ?.Error.t
	    val perm: ?.Error.t
	    val pipe: ?.Error.t
	    val range: ?.Error.t
	    val rofs: ?.Error.t
	    val spipe: ?.Error.t
	    val srch: ?.Error.t
	    val toWord: ?.Error.t -> Word64.t
	    val toobig: ?.Error.t
	    val xdev: ?.Error.t
	 end
      structure ExitStatus:
	 sig
	    datatype t = Exited
		       | ExitStatus of Word8.t
		       | Signaled of ?.Signal.t
		       | Stopped of ?.Signal.t
	    val ofStatus: Int32.t -> ?.ExitStatus.t
	 end
      structure Fcntl:
	 sig
	    type ('a, 'b) t = ('a, 'b) ?.Fcntl.t
	    val dupfd: (?.FileDesc.t, ?.FileDesc.t) ?.Fcntl.t
	    val getfd: (unit, ?.FileDescFlags.t) ?.Fcntl.t
	    val getfl: (unit, (?.FileStatusFlags.t * ?.OpenMode.t)) ?.Fcntl.t
	    val getlk: (?.Lock.t, ?.Lock.t) ?.Fcntl.t
	    val setfd: (?.FileDescFlags.t, unit) ?.Fcntl.t
	    val setfl: (?.FileStatusFlags.t, unit) ?.Fcntl.t
	    val setlk: (?.Lock.t, ?.Lock.t) ?.Fcntl.t
	    val setlkw: (?.Lock.t, ?.Lock.t) ?.Fcntl.t
	 end
      structure FileDesc:
	 sig
	    type t = ?.FileDesc.t
	    val ofIODesc: Int32.t -> ?.FileDesc.t option
	    val ofWord: Word64.t -> ?.FileDesc.t
	    val stderr: ?.FileDesc.t
	    val stdin: ?.FileDesc.t
	    val stdout: ?.FileDesc.t
	    val toIODesc: ?.FileDesc.t -> Int32.t
	    val toWord: ?.FileDesc.t -> Word64.t
	 end
      structure FileDescFlags:
	 sig
	    type t = ?.FileDescFlags.t
	    val all: ?.FileDescFlags.t
	    val cloexec: ?.FileDescFlags.t
	    val difference: (?.FileDescFlags.t * ?.FileDescFlags.t)
			    -> ?.FileDescFlags.t
	    val doIntersect: (?.FileDescFlags.t * ?.FileDescFlags.t) -> bool
	    val fromWord: Word64.t -> ?.FileDescFlags.t
	    val intersect: ?.FileDescFlags.t list -> ?.FileDescFlags.t
	    val isSubset: (?.FileDescFlags.t * ?.FileDescFlags.t) -> bool
	    val toWord: ?.FileDescFlags.t -> Word64.t
	    val union: ?.FileDescFlags.t list -> ?.FileDescFlags.t
	 end
      structure FileStatusFlags:
	 sig
	    type t = ?.FileStatusFlags.t
	    val all: ?.FileStatusFlags.t
	    val append: ?.FileStatusFlags.t
	    val difference: (?.FileStatusFlags.t * ?.FileStatusFlags.t)
			    -> ?.FileStatusFlags.t
	    val doIntersect: (?.FileStatusFlags.t * ?.FileStatusFlags.t) -> bool
	    val fromWord: Word64.t -> ?.FileStatusFlags.t
	    val intersect: ?.FileStatusFlags.t list -> ?.FileStatusFlags.t
	    val isSubset: (?.FileStatusFlags.t * ?.FileStatusFlags.t) -> bool
	    val nonblock: ?.FileStatusFlags.t
	    val sync: ?.FileStatusFlags.t
	    val toWord: ?.FileStatusFlags.t -> Word64.t
	    val union: ?.FileStatusFlags.t list -> ?.FileStatusFlags.t
	 end
      structure FlowAction:
	 sig
	    type t = ?.FlowAction.t
	    val ioff: ?.FlowAction.t
	    val ion: ?.FlowAction.t
	    val ooff: ?.FlowAction.t
	    val oon: ?.FlowAction.t
	 end
      structure Gid:
	 sig
	    type t = ?.Gid.t
	    val ofWord: Word64.t -> ?.Gid.t
	    val toWord: ?.Gid.t -> Word64.t
	 end
      structure Group:
	 sig
	    type t = ?.Group.t
	    val gid: ?.Group.t -> ?.Gid.t
	    val members: ?.Group.t -> string list
	    val name: ?.Group.t -> string
	 end
      structure Ino:
	 sig
	    type t = ?.Ino.t
	    val ofWord: Word64.t -> ?.Ino.t
	    val toWord: ?.Ino.t -> Word64.t
	 end
      structure KillArg:
	 sig
	    type t = ?.KillArg.t
	    val group: ?.Pid.t -> ?.KillArg.t
	    val proc: ?.Pid.t -> ?.KillArg.t
	    val sameGroup: ?.KillArg.t
	 end
      structure Lock:
	 sig
	    type t = ?.Lock.t
	    val len: ?.Lock.t -> Int64.t
	    val make: {len: Int64.t,
		       pid: ?.Pid.t option,
		       start: Int64.t,
		       ty: ?.Lock.Type.t,
		       whence: ?.Whence.t}
		      -> ?.Lock.t
	    val pid: ?.Lock.t -> ?.Pid.t option
	    val start: ?.Lock.t -> Int64.t
	    val ty: ?.Lock.t -> ?.Lock.Type.t
	    val whence: ?.Lock.t -> ?.Whence.t
	    structure Type:
	       sig
		  type t = ?.Lock.Type.t
		  val read: ?.Lock.Type.t
		  val unlocked: ?.Lock.Type.t
		  val write: ?.Lock.Type.t
	       end
	 end
      structure Mode:
	 sig
	    type t = ?.Mode.t
	    val all: ?.Mode.t
	    val difference: (?.Mode.t * ?.Mode.t) -> ?.Mode.t
	    val doIntersect: (?.Mode.t * ?.Mode.t) -> bool
	    val fromWord: Word64.t -> ?.Mode.t
	    val intersect: ?.Mode.t list -> ?.Mode.t
	    val irgrp: ?.Mode.t
	    val iroth: ?.Mode.t
	    val irusr: ?.Mode.t
	    val irwxg: ?.Mode.t
	    val irwxo: ?.Mode.t
	    val irwxu: ?.Mode.t
	    val isSubset: (?.Mode.t * ?.Mode.t) -> bool
	    val isgid: ?.Mode.t
	    val isuid: ?.Mode.t
	    val iwgrp: ?.Mode.t
	    val iwoth: ?.Mode.t
	    val iwusr: ?.Mode.t
	    val ixgrp: ?.Mode.t
	    val ixoth: ?.Mode.t
	    val ixusr: ?.Mode.t
	    val toWord: ?.Mode.t -> Word64.t
	    val union: ?.Mode.t list -> ?.Mode.t
	 end
      structure OpenFlags:
	 sig
	    type t = ?.OpenFlags.t
	    val all: ?.OpenFlags.t
	    val append: ?.OpenFlags.t
	    val difference: (?.OpenFlags.t * ?.OpenFlags.t) -> ?.OpenFlags.t
	    val doIntersect: (?.OpenFlags.t * ?.OpenFlags.t) -> bool
	    val excl: ?.OpenFlags.t
	    val fromWord: Word64.t -> ?.OpenFlags.t
	    val intersect: ?.OpenFlags.t list -> ?.OpenFlags.t
	    val isSubset: (?.OpenFlags.t * ?.OpenFlags.t) -> bool
	    val noctty: ?.OpenFlags.t
	    val nonblock: ?.OpenFlags.t
	    val sync: ?.OpenFlags.t
	    val toWord: ?.OpenFlags.t -> Word64.t
	    val trunc: ?.OpenFlags.t
	    val union: ?.OpenFlags.t list -> ?.OpenFlags.t
	 end
      structure OpenMode:
	 sig
	    type t = ?.OpenMode.t
	    val read: ?.OpenMode.t
	    val readWrite: ?.OpenMode.t
	    val write: ?.OpenMode.t
	 end
      structure Passwd:
	 sig
	    type t = ?.Passwd.t
	    val gid: ?.Passwd.t -> ?.Gid.t
	    val home: ?.Passwd.t -> string
	    val name: ?.Passwd.t -> string
	    val shell: ?.Passwd.t -> string
	    val uid: ?.Passwd.t -> ?.Uid.t
	 end
      structure Pid:
	 sig
	    type t = ?.Pid.t
	    val ofWord: Word64.t -> ?.Pid.t
	    val toWord: ?.Pid.t -> Word64.t
	 end
      structure QueueSel:
	 sig
	    type t = ?.QueueSel.t
	    val both: ?.QueueSel.t
	    val input: ?.QueueSel.t
	    val output: ?.QueueSel.t
	 end
      structure SetAction:
	 sig
	    type t = ?.SetAction.t
	    val drain: ?.SetAction.t
	    val flush: ?.SetAction.t
	    val now: ?.SetAction.t
	 end
      structure Signal:
	 sig
	    type t = ?.Signal.t
	    val abrt: ?.Signal.t
	    val alrm: ?.Signal.t
	    val bus: ?.Signal.t
	    val chld: ?.Signal.t
	    val cont: ?.Signal.t
	    val fpe: ?.Signal.t
	    val hup: ?.Signal.t
	    val ill: ?.Signal.t
	    val int: ?.Signal.t
	    val kill: ?.Signal.t
	    val ofWord: Word64.t -> ?.Signal.t
	    val pipe: ?.Signal.t
	    val quit: ?.Signal.t
	    val segv: ?.Signal.t
	    val stop: ?.Signal.t
	    val term: ?.Signal.t
	    val toWord: ?.Signal.t -> Word64.t
	    val tstp: ?.Signal.t
	    val ttin: ?.Signal.t
	    val ttou: ?.Signal.t
	    val usr1: ?.Signal.t
	    val usr2: ?.Signal.t
	 end
      structure Stat:
	 sig
	    type t = ?.Stat.t
	    val atime: ?.Stat.t -> Time.t
	    val ctime: ?.Stat.t -> Time.t
	    val dev: ?.Stat.t -> ?.Dev.t
	    val gid: ?.Stat.t -> ?.Gid.t
	    val ino: ?.Stat.t -> ?.Ino.t
	    val isBlk: ?.Stat.t -> bool
	    val isChr: ?.Stat.t -> bool
	    val isDir: ?.Stat.t -> bool
	    val isFIFO: ?.Stat.t -> bool
	    val isLink: ?.Stat.t -> bool
	    val isReg: ?.Stat.t -> bool
	    val isSock: ?.Stat.t -> bool
	    val mode: ?.Stat.t -> ?.Mode.t
	    val mtime: ?.Stat.t -> Time.t
	    val nlink: ?.Stat.t -> Int32.t
	    val size: ?.Stat.t -> Int64.t
	    val uid: ?.Stat.t -> ?.Uid.t
	 end
      structure Termios:
	 sig
	    datatype t = T of {c: ?.Termios.C.t,
			       cc: ?.Termios.CC.t,
			       i: ?.Termios.I.t,
			       ispeed: ?.Termios.Speed.t,
			       l: ?.Termios.L.t,
			       o: ?.Termios.O.t,
			       ospeed: ?.Termios.Speed.t}
	    structure C:
	       sig
		  type t = ?.Termios.C.t
		  val all: ?.Termios.C.t
		  val clocal: ?.Termios.C.t
		  val cread: ?.Termios.C.t
		  val cs5: ?.Termios.C.t
		  val cs6: ?.Termios.C.t
		  val cs7: ?.Termios.C.t
		  val cs8: ?.Termios.C.t
		  val csize: ?.Termios.C.t
		  val cstopb: ?.Termios.C.t
		  val difference: (?.Termios.C.t * ?.Termios.C.t)
				  -> ?.Termios.C.t
		  val doIntersect: (?.Termios.C.t * ?.Termios.C.t) -> bool
		  val fromWord: Word64.t -> ?.Termios.C.t
		  val hupcl: ?.Termios.C.t
		  val intersect: ?.Termios.C.t list -> ?.Termios.C.t
		  val isSubset: (?.Termios.C.t * ?.Termios.C.t) -> bool
		  val parenb: ?.Termios.C.t
		  val parodd: ?.Termios.C.t
		  val toWord: ?.Termios.C.t -> Word64.t
		  val union: ?.Termios.C.t list -> ?.Termios.C.t
	       end
	    structure CC:
	       sig
		  type t = ?.Termios.CC.t
		  val eof: Int32.t
		  val eol: Int32.t
		  val erase: Int32.t
		  val intr: Int32.t
		  val kill: Int32.t
		  val make: (Int32.t * char) list -> ?.Termios.CC.t
		  val min: Int32.t
		  val nccs: Int32.t
		  val quit: Int32.t
		  val start: Int32.t
		  val stop: Int32.t
		  val sub: (?.Termios.CC.t * Int32.t) -> char
		  val susp: Int32.t
		  val time: Int32.t
		  val update: (?.Termios.CC.t * (Int32.t * char) list)
			      -> ?.Termios.CC.t
	       end
	    structure I:
	       sig
		  type t = ?.Termios.I.t
		  val all: ?.Termios.I.t
		  val brkint: ?.Termios.I.t
		  val difference: (?.Termios.I.t * ?.Termios.I.t)
				  -> ?.Termios.I.t
		  val doIntersect: (?.Termios.I.t * ?.Termios.I.t) -> bool
		  val fromWord: Word64.t -> ?.Termios.I.t
		  val icrnl: ?.Termios.I.t
		  val ignbrk: ?.Termios.I.t
		  val igncr: ?.Termios.I.t
		  val ignpar: ?.Termios.I.t
		  val inlcr: ?.Termios.I.t
		  val inpck: ?.Termios.I.t
		  val intersect: ?.Termios.I.t list -> ?.Termios.I.t
		  val isSubset: (?.Termios.I.t * ?.Termios.I.t) -> bool
		  val istrip: ?.Termios.I.t
		  val ixoff: ?.Termios.I.t
		  val ixon: ?.Termios.I.t
		  val parmrk: ?.Termios.I.t
		  val toWord: ?.Termios.I.t -> Word64.t
		  val union: ?.Termios.I.t list -> ?.Termios.I.t
	       end
	    structure L:
	       sig
		  type t = ?.Termios.L.t
		  val all: ?.Termios.L.t
		  val difference: (?.Termios.L.t * ?.Termios.L.t)
				  -> ?.Termios.L.t
		  val doIntersect: (?.Termios.L.t * ?.Termios.L.t) -> bool
		  val echo: ?.Termios.L.t
		  val echoe: ?.Termios.L.t
		  val echok: ?.Termios.L.t
		  val echonl: ?.Termios.L.t
		  val fromWord: Word64.t -> ?.Termios.L.t
		  val icanon: ?.Termios.L.t
		  val iexten: ?.Termios.L.t
		  val intersect: ?.Termios.L.t list -> ?.Termios.L.t
		  val isSubset: (?.Termios.L.t * ?.Termios.L.t) -> bool
		  val isig: ?.Termios.L.t
		  val noflsh: ?.Termios.L.t
		  val toWord: ?.Termios.L.t -> Word64.t
		  val tostop: ?.Termios.L.t
		  val union: ?.Termios.L.t list -> ?.Termios.L.t
	       end
	    structure O:
	       sig
		  type t = ?.Termios.O.t
		  val all: ?.Termios.O.t
		  val difference: (?.Termios.O.t * ?.Termios.O.t)
				  -> ?.Termios.O.t
		  val doIntersect: (?.Termios.O.t * ?.Termios.O.t) -> bool
		  val fromWord: Word64.t -> ?.Termios.O.t
		  val intersect: ?.Termios.O.t list -> ?.Termios.O.t
		  val isSubset: (?.Termios.O.t * ?.Termios.O.t) -> bool
		  val opost: ?.Termios.O.t
		  val toWord: ?.Termios.O.t -> Word64.t
		  val union: ?.Termios.O.t list -> ?.Termios.O.t
	       end
	    structure Speed:
	       sig
		  type t = ?.Termios.Speed.t
		  val b0: ?.Termios.Speed.t
		  val b110: ?.Termios.Speed.t
		  val b1200: ?.Termios.Speed.t
		  val b134: ?.Termios.Speed.t
		  val b150: ?.Termios.Speed.t
		  val b1800: ?.Termios.Speed.t
		  val b19200: ?.Termios.Speed.t
		  val b200: ?.Termios.Speed.t
		  val b2400: ?.Termios.Speed.t
		  val b300: ?.Termios.Speed.t
		  val b38400: ?.Termios.Speed.t
		  val b4800: ?.Termios.Speed.t
		  val b50: ?.Termios.Speed.t
		  val b600: ?.Termios.Speed.t
		  val b75: ?.Termios.Speed.t
		  val b9600: ?.Termios.Speed.t
		  val ofWord: Word64.t -> ?.Termios.Speed.t
		  val toWord: ?.Termios.Speed.t -> Word64.t
	       end
	 end
      structure Uid:
	 sig
	    type t = ?.Uid.t
	    val ofWord: Word64.t -> ?.Uid.t
	    val toWord: ?.Uid.t -> Word64.t
	 end
      structure WaitPidArg:
	 sig
	    type t = ?.WaitPidArg.t
	    val anyChild: ?.WaitPidArg.t
	    val child: ?.Pid.t -> ?.WaitPidArg.t
	    val group: ?.Pid.t -> ?.WaitPidArg.t
	    val sameGroup: ?.WaitPidArg.t
	 end
      structure WaitPidFlags:
	 sig
	    type t = ?.WaitPidFlags.t
	    val all: ?.WaitPidFlags.t
	    val difference: (?.WaitPidFlags.t * ?.WaitPidFlags.t)
			    -> ?.WaitPidFlags.t
	    val doIntersect: (?.WaitPidFlags.t * ?.WaitPidFlags.t) -> bool
	    val fromWord: Word64.t -> ?.WaitPidFlags.t
	    val intersect: ?.WaitPidFlags.t list -> ?.WaitPidFlags.t
	    val isSubset: (?.WaitPidFlags.t * ?.WaitPidFlags.t) -> bool
	    val toWord: ?.WaitPidFlags.t -> Word64.t
	    val union: ?.WaitPidFlags.t list -> ?.WaitPidFlags.t
	    val untraced: ?.WaitPidFlags.t
	 end
      structure Whence:
	 sig
	    type t = ?.Whence.t
	    val cur: ?.Whence.t
	    val endd: ?.Whence.t
	    val set: ?.Whence.t
	 end
   end
signature PROCESS = 
   sig
      val atExit: (unit -> unit) -> unit
      val exit: ?.Status.t -> 'a
      val getEnv: string -> string option
      val sleep: Time.t -> unit
      val system: string -> ?.Status.t
      val terminate: ?.Status.t -> 'a
      structure Status:
	 sig
	    type t = ?.Status.t
	    val failure: ?.Status.t
	    val isSuccess: ?.Status.t -> bool
	    val success: ?.Status.t
	 end
   end
signature RADIX = 
   sig
      type t = ?.t
      val bin: ?.t
      val dec: ?.t
      val hex: ?.t
      val oct: ?.t
      val toString: ?.t -> string
   end
signature REAL = 
   sig
      type t = ?.t
      val != : (?.t * ?.t) -> bool
      val * : (?.t * ?.t) -> ?.t
      val + : (?.t * ?.t) -> ?.t
      val - : (?.t * ?.t) -> ?.t
      val / : (?.t * ?.t) -> ?.t
      val < : (?.t * ?.t) -> bool
      val <= : (?.t * ?.t) -> bool
      val == : (?.t * ?.t) -> bool
      val > : (?.t * ?.t) -> bool
      val >= : (?.t * ?.t) -> bool
      val ?= : (?.t * ?.t) -> bool
      val abs: ?.t -> ?.t
      val acos: ?.t -> ?.t
      val asin: ?.t -> ?.t
      val atan: ?.t -> ?.t
      val atan2: (?.t * ?.t) -> ?.t
      val ceil: ?.t -> Int32.t
      val checkFloat: ?.t -> ?.t
      val class: ?.t -> ?.Class.t
      val compare: (?.t * ?.t) -> order
      val copySign: (?.t * ?.t) -> ?.t
      val cos: ?.t -> ?.t
      val cosh: ?.t -> ?.t
      val e: ?.t
      val exp: ?.t -> ?.t
      val floor: ?.t -> Int32.t
      val format: (?.t * ?.Format.t) -> string
      val isFinite: ?.t -> bool
      val isNan: ?.t -> bool
      val isNormal: ?.t -> bool
      val ln: ?.t -> ?.t
      val log10: ?.t -> ?.t
      val max: (?.t * ?.t) -> ?.t
      val maxFinite: ?.t
      val min: (?.t * ?.t) -> ?.t
      val minNormalPos: ?.t
      val minPos: ?.t
      val negInf: ?.t
      val nextAfter: (?.t * ?.t) -> ?.t
      val ofDecimal: {class: ?.Class.t,
		      digits: Int32.t list,
		      exp: Int32.t,
		      sign: bool}
		     -> ?.t option
      val ofInt: Int32.t -> ?.t
      val ofLarge: (Real64.t * ?.RoundingMode.t) -> ?.t
      val ofLargeInt: IntInf.t -> ?.t
      val ofManExp: {exp: Int32.t, man: ?.t} -> ?.t
      val ofString: string -> ?.t option
      val pi: ?.t
      val posInf: ?.t
      val pow: (?.t * ?.t) -> ?.t
      val precision: Int32.t
      val radix: Int32.t
      val realCeil: ?.t -> ?.t
      val realFloor: ?.t -> ?.t
      val realMod: ?.t -> ?.t
      val realRound: ?.t -> ?.t
      val realTrunc: ?.t -> ?.t
      val rem: (?.t * ?.t) -> ?.t
      val round: ?.t -> Int32.t
      val sameSign: (?.t * ?.t) -> bool
      val scanner: char seq -> (?.t * char seq) option
      val sign: ?.t -> Int32.t
      val signBit: ?.t -> bool
      val sin: ?.t -> ?.t
      val sinh: ?.t -> ?.t
      val split: ?.t -> {frac: ?.t, whole: ?.t}
      val sqrt: ?.t -> ?.t
      val tan: ?.t -> ?.t
      val tanh: ?.t -> ?.t
      val toDecimal: ?.t
		     -> {class: ?.Class.t,
			 digits: Int32.t list,
			 exp: Int32.t,
			 sign: bool}
      val toInt: (?.t * ?.RoundingMode.t) -> Int32.t
      val toLarge: ?.t -> Real64.t
      val toLargeInt: (?.t * ?.RoundingMode.t) -> IntInf.t
      val toManExp: ?.t -> {exp: Int32.t, man: ?.t}
      val toString: ?.t -> string
      val trunc: ?.t -> Int32.t
      val unordered: (?.t * ?.t) -> bool
      val ~ : ?.t -> ?.t
      structure Class:
	 sig
	    datatype t = Inf | Nan | Normal | Subnormal | Zero
	 end
      structure Decimal:
	 sig
	    eqtype t = {class: ?.Class.t,
			digits: Int32.t list,
			exp: Int32.t,
			sign: bool}
	    val ofString: string
			  -> {class: ?.Class.t,
			      digits: Int32.t list,
			      exp: Int32.t,
			      sign: bool} option
	    val scanner: char seq
			 -> ({class: ?.Class.t,
			      digits: Int32.t list,
			      exp: Int32.t,
			      sign: bool}
			     * char seq) option
	    val toString: {class: ?.Class.t,
			   digits: Int32.t list,
			   exp: Int32.t,
			   sign: bool}
			  -> string
	 end
      structure Format:
	 sig
	    type t = ?.Format.t
	    val exact: ?.Format.t
	    val fix: Int32.t -> ?.Format.t
	    val gen: Int32.t -> ?.Format.t
	    val sci: Int32.t -> ?.Format.t
	 end
      structure RoundingMode:
	 sig
	    type t = ?.RoundingMode.t
	    val get: unit -> ?.RoundingMode.t
	    val nearest: ?.RoundingMode.t
	    val negInf: ?.RoundingMode.t
	    val posInf: ?.RoundingMode.t
	    val set: ?.RoundingMode.t -> unit
	    val zero: ?.RoundingMode.t
	 end
   end
signature REF = 
   sig
      datatype 'a t = ref of 'a
      val ! : 'a Ref.t -> 'a
      val := : ('a Ref.t * 'a) -> unit
   end
signature SCANNER = 
   sig
      type 'a t = 'a ?.t
      val make: (char seq -> ('a * char seq) option) -> 'a ?.t
      val map: ('a ?.t * ('a -> 'b)) -> 'b ?.t
      val scan: ('a ?.t * char seq) -> ('a * char seq) option
   end
signature SEQ = 
   sig
      type 'a elem = 'a ?.elem
      type 'a t = 'a ?.t
      type 'a t0 = 'a ?.t
      type 'a unfold = 'a ?.unfold
      type 'a unfoldR = 'a ?.unfoldR
      val all: ('a ?.t * ('a ?.elem -> bool)) -> bool
      val append: ('a ?.t * 'a ?.t) -> 'a ?.t
      val concat: 'a ?.t seq -> 'a ?.t
      val cons: ('a ?.elem * 'a ?.t) -> 'a ?.t
      val delay: (unit -> 'a ?.t) -> 'a ?.t
      val drop: ('a ?.t * ('a ?.elem -> bool)) -> 'a ?.t
      val dropPrefix: ('a ?.t * ('a ?.elem -> bool)) -> 'a ?.t
      val dropPrefixN: ('a ?.t * Int32.t) -> 'a ?.t
      val dropSuffix: ('a ?.t * ('a ?.elem -> bool)) -> 'a ?.t
      val dropSuffixN: ('a ?.t * Int32.t) -> 'a ?.t
      val empty: unit -> 'a ?.t
      val exists: ('a ?.t * ('a ?.elem -> bool)) -> bool
      val fields: ('a ?.t * ('a ?.elem -> bool)) -> 'a ?.t seq
      val find: ('a ?.t * ('a ?.elem -> bool)) -> 'a ?.elem option
      val fold: ('a ?.t * 'b * (('a ?.elem * 'b) -> 'b)) -> 'b
      val for: ('a ?.t * ('a ?.elem -> unit)) -> unit
      val get: 'a ?.t -> ('a * 'a ?.t) option
      val isEmpty: 'a ?.t -> bool
      val join: ('a ?.t seq * 'a ?.t) -> 'a ?.t
      val keep: ('a ?.t * ('a ?.elem -> bool)) -> 'a ?.t
      val keepPrefix: ('a ?.t * ('a ?.elem -> bool)) -> 'a ?.t
      val keepPrefixN: ('a ?.t * Int32.t) -> 'a ?.t
      val keepSuffix: ('a ?.t * ('a ?.elem -> bool)) -> 'a ?.t
      val keepSuffixN: ('a ?.t * Int32.t) -> 'a ?.t
      val last: 'a ?.t -> 'a ?.elem
      val map: ('a ?.t * ('a ?.elem -> 'b ?.elem)) -> 'b ?.t
      val ofSeq: 'a ?.elem seq -> 'a ?.t
      val ofSeqN: ('a ?.elem seq * Int32.t) -> 'a ?.t
      val recur: ('a ?.t
		  * 'b
		  * ('b -> 'c)
		  * (('a ?.elem * 'b * ('b -> 'c)) -> 'c))
		 -> 'c
      val reverse: 'a ?.t -> 'a ?.t
      val separate: ('a ?.t * 'a ?.elem) -> 'a ?.t
      val single: 'a ?.elem -> 'a ?.t
      val size: 'a ?.t -> Int32.t
      val splitPrefix: ('a ?.t * ('a ?.elem -> bool)) -> ('a ?.t * 'a ?.t)
      val sub: ('a ?.t * Int32.t) -> 'a ?.elem
      val tabulate: (Int32.t * (Int32.t -> 'a ?.elem)) -> 'a ?.t
      val toSeq: 'a ?.t -> 'a ?.elem seq
      val toSeqR: 'a ?.t -> 'a ?.elem seq
      val tokens: ('a ?.t * ('a ?.elem -> bool)) -> 'a ?.t seq
      val unfold: ('a * ('a -> ('b ?.elem * 'a) option))
		  -> ('b ?.t * 'a ?.unfold)
      val unfoldN: (Int32.t * 'a * ((Int32.t * 'a) -> ('b ?.elem * 'a) option))
		   -> ('b ?.t * 'a ?.unfold)
      val unfoldNR: (Int32.t * 'a * ((Int32.t * 'a) -> ('b ?.elem * 'a) option))
		    -> ('b ?.t * 'a ?.unfoldR)
      val unfoldR: ('a * ('a -> ('b ?.elem * 'a) option))
		   -> ('b ?.t * 'a ?.unfoldR)
   end
signature STRING = 
   sig
      eqtype 'a elem = char
      type t = ?.t
      type 'a t0 = ?.t
      type 'a unfold = 'a ?.unfold
      type 'a unfoldR = 'a ?.unfoldR
      val all: (?.t * (char -> bool)) -> bool
      val append: (?.t * ?.t) -> ?.t
      val concat: ?.t seq -> ?.t
      val cons: (char * ?.t) -> ?.t
      val drop: (?.t * (char -> bool)) -> ?.t
      val dropPrefix: (?.t * (char -> bool)) -> ?.t
      val dropPrefixN: (?.t * Int32.t) -> ?.t
      val dropSuffix: (?.t * (char -> bool)) -> ?.t
      val dropSuffixN: (?.t * Int32.t) -> ?.t
      val empty: unit -> ?.t
      val exists: (?.t * (char -> bool)) -> bool
      val fields: (?.t * (char -> bool)) -> ?.t seq
      val find: (?.t * (char -> bool)) -> char option
      val fold: (?.t * 'a * ((char * 'a) -> 'a)) -> 'a
      val for: (?.t * (char -> unit)) -> unit
      val hasPrefix: (?.t * ?.t) -> bool
      val isEmpty: ?.t -> bool
      val join: (?.t seq * ?.t) -> ?.t
      val keep: (?.t * (char -> bool)) -> ?.t
      val keepPrefix: (?.t * (char -> bool)) -> ?.t
      val keepPrefixN: (?.t * Int32.t) -> ?.t
      val keepSuffix: (?.t * (char -> bool)) -> ?.t
      val keepSuffixN: (?.t * Int32.t) -> ?.t
      val last: ?.t -> char
      val make: Int32.t
		-> {done: unit -> ?.t,
		    sub: Int32.t -> char,
		    update: (Int32.t * char) -> unit}
      val map: (?.t * (char -> char)) -> ?.t
      val ofSeq: char seq -> ?.t
      val ofSeqN: (char seq * Int32.t) -> ?.t
      val recur: (?.t * 'a * ('a -> 'b) * ((char * 'a * ('a -> 'b)) -> 'b))
		 -> 'b
      val reverse: ?.t -> ?.t
      val separate: (?.t * char) -> ?.t
      val single: char -> ?.t
      val size: ?.t -> Int32.t
      val splitPrefix: (?.t * (char -> bool)) -> (?.t * ?.t)
      val sub: (?.t * Int32.t) -> char
      val tabulate: (Int32.t * (Int32.t -> char)) -> ?.t
      val toLower: ?.t -> ?.t
      val toSeq: ?.t -> char seq
      val toSeqR: ?.t -> char seq
      val toUpper: ?.t -> ?.t
      val tokens: (?.t * (char -> bool)) -> ?.t seq
      val unfold: ('a * ('a -> (char * 'a) option)) -> (?.t * 'a ?.unfold)
      val unfoldN: (Int32.t * 'a * ((Int32.t * 'a) -> (char * 'a) option))
		   -> (?.t * 'a ?.unfold)
      val unfoldNR: (Int32.t * 'a * ((Int32.t * 'a) -> (char * 'a) option))
		    -> (?.t * 'a ?.unfoldR)
      val unfoldR: ('a * ('a -> (char * 'a) option)) -> (?.t * 'a ?.unfoldR)
      structure Unsafe:
	 sig
	    val sub: (?.t * Int32.t) -> char
	 end
   end
signature SUBSTRING = 
   sig
      type 'a base = 'a ?.base
      eqtype 'a elem = char
      type t = ?.t
      type 'a t0 = ?.t
      val all: (?.t * (char -> bool)) -> bool
      val base: ?.t -> ('a ?.base * {start: Int32.t})
      val dropPrefix: (?.t * (char -> bool)) -> ?.t
      val dropPrefixN: (?.t * Int32.t) -> ?.t
      val dropSuffix: (?.t * (char -> bool)) -> ?.t
      val dropSuffixN: (?.t * Int32.t) -> ?.t
      val exists: (?.t * (char -> bool)) -> bool
      val fields: (?.t * (char -> bool)) -> ?.t seq
      val find: (?.t * (char -> bool)) -> char option
      val fold: (?.t * 'a * ((char * 'a) -> 'a)) -> 'a
      val for: (?.t * (char -> unit)) -> unit
      val full: 'a ?.base -> ?.t
      val get: ?.t -> (char * ?.t) option
      val isEmpty: ?.t -> bool
      val keepPrefix: (?.t * (char -> bool)) -> ?.t
      val keepPrefixN: (?.t * Int32.t) -> ?.t
      val keepSuffix: (?.t * (char -> bool)) -> ?.t
      val keepSuffixN: (?.t * Int32.t) -> ?.t
      val last: ?.t -> char
      val map: (?.t * (char -> char)) -> 'a ?.base
      val recur: (?.t * 'a * ('a -> 'b) * ((char * 'a * ('a -> 'b)) -> 'b))
		 -> 'b
      val size: ?.t -> Int32.t
      val slice: (?.t * {size: Int32.t, start: Int32.t}) -> ?.t
      val splitPrefix: (?.t * (char -> bool)) -> (?.t * ?.t)
      val sub: (?.t * Int32.t) -> char
      val toSeq: ?.t -> char seq
      val toSeqR: ?.t -> char seq
      val tokens: (?.t * (char -> bool)) -> ?.t seq
   end
signature SYS_ERROR = 
   sig
      type t = ?.t
      val == : (?.t * ?.t) -> bool
      val message: ?.t -> string
      val name: ?.t -> string
      val ofName: string -> ?.t option
      structure Exn:
	 sig
	    type error = ?.t
	    type t = ?.Exn.t
	    exception E of ?.Exn.t
	    val error: ?.Exn.t -> ?.t option
	    val message: ?.Exn.t -> string
	 end
   end
signature TIME = 
   sig
      type t = ?.t
      val + : (?.t * ?.t) -> ?.t
      val - : (?.t * ?.t) -> ?.t
      val < : (?.t * ?.t) -> bool
      val <= : (?.t * ?.t) -> bool
      val == : (?.t * ?.t) -> bool
      val > : (?.t * ?.t) -> bool
      val >= : (?.t * ?.t) -> bool
      exception Time
      val compare: (?.t * ?.t) -> order
      val format: (?.t * {fractionalDigits: Int32.t}) -> string
      val fromReal: Real64.t -> ?.t
      val now: unit -> ?.t
      val ofMicroseconds: IntInf.t -> ?.t
      val ofMilliseconds: IntInf.t -> ?.t
      val ofNanoseconds: IntInf.t -> ?.t
      val ofSeconds: IntInf.t -> ?.t
      val ofString: string -> ?.t option
      val scanner: char seq -> (?.t * char seq) option
      val toMicroseconds: ?.t -> IntInf.t
      val toMilliseconds: ?.t -> IntInf.t
      val toNanoseconds: ?.t -> IntInf.t
      val toReal: ?.t -> Real64.t
      val toSeconds: ?.t -> IntInf.t
      val toString: ?.t -> string
      val zero: ?.t
   end
signature VECTOR = 
   sig
      type 'a elem = 'a ?.elem
      type 'a t = 'a ?.t
      type 'a t0 = 'a ?.t
      type 'a unfold = 'a ?.unfold
      type 'a unfoldR = 'a ?.unfoldR
      val all: ('a ?.t * ('a ?.elem -> bool)) -> bool
      val append: ('a ?.t * 'a ?.t) -> 'a ?.t
      val concat: 'a ?.t seq -> 'a ?.t
      val cons: ('a ?.elem * 'a ?.t) -> 'a ?.t
      val drop: ('a ?.t * ('a ?.elem -> bool)) -> 'a ?.t
      val dropPrefix: ('a ?.t * ('a ?.elem -> bool)) -> 'a ?.t
      val dropPrefixN: ('a ?.t * Int32.t) -> 'a ?.t
      val dropSuffix: ('a ?.t * ('a ?.elem -> bool)) -> 'a ?.t
      val dropSuffixN: ('a ?.t * Int32.t) -> 'a ?.t
      val empty: unit -> 'a ?.t
      val exists: ('a ?.t * ('a ?.elem -> bool)) -> bool
      val fields: ('a ?.t * ('a ?.elem -> bool)) -> 'a ?.t seq
      val find: ('a ?.t * ('a ?.elem -> bool)) -> 'a ?.elem option
      val fold: ('a ?.t * 'b * (('a ?.elem * 'b) -> 'b)) -> 'b
      val for: ('a ?.t * ('a ?.elem -> unit)) -> unit
      val isEmpty: 'a ?.t -> bool
      val join: ('a ?.t seq * 'a ?.t) -> 'a ?.t
      val keep: ('a ?.t * ('a ?.elem -> bool)) -> 'a ?.t
      val keepPrefix: ('a ?.t * ('a ?.elem -> bool)) -> 'a ?.t
      val keepPrefixN: ('a ?.t * Int32.t) -> 'a ?.t
      val keepSuffix: ('a ?.t * ('a ?.elem -> bool)) -> 'a ?.t
      val keepSuffixN: ('a ?.t * Int32.t) -> 'a ?.t
      val last: 'a ?.t -> 'a ?.elem
      val make: Int32.t
		-> {done: unit -> 'a ?.t,
		    sub: Int32.t -> 'a ?.elem,
		    update: (Int32.t * 'a ?.elem) -> unit}
      val map: ('a ?.t * ('a ?.elem -> 'b ?.elem)) -> 'b ?.t
      val ofSeq: 'a ?.elem seq -> 'a ?.t
      val ofSeqN: ('a ?.elem seq * Int32.t) -> 'a ?.t
      val recur: ('a ?.t
		  * 'b
		  * ('b -> 'c)
		  * (('a ?.elem * 'b * ('b -> 'c)) -> 'c))
		 -> 'c
      val reverse: 'a ?.t -> 'a ?.t
      val separate: ('a ?.t * 'a ?.elem) -> 'a ?.t
      val single: 'a ?.elem -> 'a ?.t
      val size: 'a ?.t -> Int32.t
      val splitPrefix: ('a ?.t * ('a ?.elem -> bool)) -> ('a ?.t * 'a ?.t)
      val sub: ('a ?.t * Int32.t) -> 'a ?.elem
      val tabulate: (Int32.t * (Int32.t -> 'a ?.elem)) -> 'a ?.t
      val toSeq: 'a ?.t -> 'a ?.elem seq
      val toSeqR: 'a ?.t -> 'a ?.elem seq
      val tokens: ('a ?.t * ('a ?.elem -> bool)) -> 'a ?.t seq
      val unfold: ('a * ('a -> ('b ?.elem * 'a) option))
		  -> ('b ?.t * 'a ?.unfold)
      val unfoldN: (Int32.t * 'a * ((Int32.t * 'a) -> ('b ?.elem * 'a) option))
		   -> ('b ?.t * 'a ?.unfold)
      val unfoldNR: (Int32.t * 'a * ((Int32.t * 'a) -> ('b ?.elem * 'a) option))
		    -> ('b ?.t * 'a ?.unfoldR)
      val unfoldR: ('a * ('a -> ('b ?.elem * 'a) option))
		   -> ('b ?.t * 'a ?.unfoldR)
      structure Unsafe:
	 sig
	    val sub: ('a ?.t * Int32.t) -> 'a ?.elem
	 end
   end
signature VECTOR_SLICE = 
   sig
      type 'a base = 'a ?.base
      type 'a elem = 'a ?.elem
      type 'a t = 'a ?.t
      type 'a t0 = 'a ?.t
      val all: ('a ?.t * ('a ?.elem -> bool)) -> bool
      val base: 'a ?.t -> ('a ?.base * {start: Int32.t})
      val dropPrefix: ('a ?.t * ('a ?.elem -> bool)) -> 'a ?.t
      val dropPrefixN: ('a ?.t * Int32.t) -> 'a ?.t
      val dropSuffix: ('a ?.t * ('a ?.elem -> bool)) -> 'a ?.t
      val dropSuffixN: ('a ?.t * Int32.t) -> 'a ?.t
      val exists: ('a ?.t * ('a ?.elem -> bool)) -> bool
      val fields: ('a ?.t * ('a ?.elem -> bool)) -> 'a ?.t seq
      val find: ('a ?.t * ('a ?.elem -> bool)) -> 'a ?.elem option
      val fold: ('a ?.t * 'b * (('a ?.elem * 'b) -> 'b)) -> 'b
      val for: ('a ?.t * ('a ?.elem -> unit)) -> unit
      val full: 'a ?.base -> 'a ?.t
      val get: 'a ?.t -> ('a ?.elem * 'a ?.t) option
      val isEmpty: 'a ?.t -> bool
      val keepPrefix: ('a ?.t * ('a ?.elem -> bool)) -> 'a ?.t
      val keepPrefixN: ('a ?.t * Int32.t) -> 'a ?.t
      val keepSuffix: ('a ?.t * ('a ?.elem -> bool)) -> 'a ?.t
      val keepSuffixN: ('a ?.t * Int32.t) -> 'a ?.t
      val last: 'a ?.t -> 'a ?.elem
      val map: ('a ?.t * ('a ?.elem -> 'b ?.elem)) -> 'b ?.base
      val recur: ('a ?.t
		  * 'b
		  * ('b -> 'c)
		  * (('a ?.elem * 'b * ('b -> 'c)) -> 'c))
		 -> 'c
      val size: 'a ?.t -> Int32.t
      val slice: ('a ?.t * {size: Int32.t, start: Int32.t}) -> 'a ?.t
      val splitPrefix: ('a ?.t * ('a ?.elem -> bool)) -> ('a ?.t * 'a ?.t)
      val sub: ('a ?.t * Int32.t) -> 'a ?.elem
      val toSeq: 'a ?.t -> 'a ?.elem seq
      val toSeqR: 'a ?.t -> 'a ?.elem seq
      val tokens: ('a ?.t * ('a ?.elem -> bool)) -> 'a ?.t seq
   end
signature WORD = 
   sig
      type t = ?.t
      val * : (?.t * ?.t) -> ?.t
      val + : (?.t * ?.t) -> ?.t
      val - : (?.t * ?.t) -> ?.t
      val < : (?.t * ?.t) -> bool
      val << : (?.t * Word32.t) -> ?.t
      val <= : (?.t * ?.t) -> bool
      val == : (?.t * ?.t) -> bool
      val > : (?.t * ?.t) -> bool
      val >= : (?.t * ?.t) -> bool
      val >> : (?.t * Word32.t) -> ?.t
      val andb: (?.t * ?.t) -> ?.t
      val compare: (?.t * ?.t) -> order
      val div: (?.t * ?.t) -> ?.t
      val mod: (?.t * ?.t) -> ?.t
      val notb: ?.t -> ?.t
      val ofLarge: Word64.t -> ?.t
      val ofString: string -> ?.t option
      val ofStringRadix: (string * Radix.t) -> ?.t option
      val orb: (?.t * ?.t) -> ?.t
      val scanner: Radix.t -> (char seq -> (?.t * char seq) option)
      val toLarge: ?.t -> Word64.t
      val toLargeX: ?.t -> Word64.t
      val toString: ?.t -> string
      val toStringRadix: (?.t * Radix.t) -> string
      val xorb: (?.t * ?.t) -> ?.t
      val ~>> : (?.t * Word32.t) -> ?.t
   end
